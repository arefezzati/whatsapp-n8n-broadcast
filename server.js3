/**
 * wa-bridge-local / server.js  (whatsapp-web.js 1.34.1)
 * ---------------------------------------------------------
 * - Lokal QR ile oturum aÃ§ (LocalAuth; ./wweb-session iÃ§ine kaydeder)
 * - /send-video : N8N'den tek alÄ±cÄ±ya video gÃ¶nder (STREAM -> /tmp -> fromFilePath)
 * - /send-video-batch : Dizi halinde alÄ±cÄ±larÄ± kuyruÄŸa ekle (tek iÅŸÃ§i, 2sn aralÄ±k)
 * - /           : QR gÃ¶rÃ¼ntÃ¼leme sayfasÄ± (otomatik yenileme)
 *
 * Notlar:
 * - Video iÃ§in base64 KULLANMIYORUZ. (QR gÃ¶rseli data URL'dir; yalnÄ±zca ekranda gÃ¶sterim.)
 * - Mac'te Chrome yolu EXECUTABLE_PATH ile ayarlanabilir (aÅŸaÄŸÄ±daki varsayÄ±lan da geÃ§erli).
 * - API'ler: LocalAuth (dataPath), MessageMedia.fromFilePath, sendMessage(..., {sendMediaAsDocument})
 */

import express from "express";
import fs from "fs";
import path from "path";
import os from "os";
import { pipeline } from "stream";
import { promisify } from "util";
import QRCode from "qrcode";
import pkg from "whatsapp-web.js";
import multer from "multer";
import winston from "winston";
// ngrok'u dinamik import edeceÄŸiz; paketlenmiÅŸ ortamlarda eksikse crash olmasÄ±n

const { Client, LocalAuth, MessageMedia } = pkg;

const app = express();
const streamPipeline = promisify(pipeline);

// ==== Winston Logger Configuration ====
// NOT: Web ortamÄ±nda (Cloud/Docker) dosya yazma sÄ±nÄ±rlamasÄ± olabilir
// Bu yÃ¼zden FILE_LOGS environment variable ile kontrol ediyoruz
const USE_FILE_LOGS = process.env.FILE_LOGS === 'true';

const getLogDirectory = () => {
  return path.join(process.cwd(), 'logs', 'whatsapp-web');
};

// Sadece file logging aktifse klasÃ¶r oluÅŸtur
let logDir;
if (USE_FILE_LOGS) {
  logDir = getLogDirectory();
  try {
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  } catch (error) {
    console.warn('[LOG] Log klasÃ¶rÃ¼ oluÅŸturulamadÄ±, sadece console log kullanÄ±lacak:', error.message);
  }
}

const transports = [
  new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  })
];

// File logging aktifse ve klasÃ¶r oluÅŸturulabilmiÅŸse file transport'larÄ± ekle
if (USE_FILE_LOGS && logDir) {
  try {
    transports.push(
      new winston.transports.File({
        filename: path.join(logDir, 'whatsapp-web.log'),
        maxsize: 10 * 1024 * 1024, // 10MB
        maxFiles: 5
      }),
      new winston.transports.File({
        filename: path.join(logDir, 'error.log'),
        level: 'error',
        maxsize: 10 * 1024 * 1024,
        maxFiles: 5
      }),
      new winston.transports.File({
        filename: path.join(logDir, 'endpoints.log'),
        maxsize: 10 * 1024 * 1024,
        maxFiles: 5
      })
    );
    console.log(`[LOG] File logging aktif: ${logDir}`);
  } catch (error) {
    console.warn('[LOG] File transport eklenemedi, sadece console log kullanÄ±lacak:', error.message);
  }
}

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.printf(({ timestamp, level, message, ...meta }) => {
      const metaStr = Object.keys(meta).length ? ' ' + JSON.stringify(meta) : '';
      return `${timestamp} [${level.toUpperCase()}] ${message}${metaStr}`;
    })
  ),
  transports: transports
});

// YENI: Endpoint logging helper
function logEndpoint(endpoint, method, data, result) {
  const logData = {
    timestamp: new Date().toISOString(),
    endpoint,
    method,
    request: data,
    result: result || 'processing',
    ready: ready
  };
  logger.info(`[ENDPOINT] ${method} ${endpoint}`, logData);
}

// Get package versions for logging
let puppeteerVersion = 'unknown';
let wwebjsVersion = 'unknown';
try {
  const puppeteerPkg = JSON.parse(fs.readFileSync(path.join(process.cwd(), 'node_modules', 'puppeteer', 'package.json'), 'utf8'));
  puppeteerVersion = puppeteerPkg.version;
  const wwebjsPkg = JSON.parse(fs.readFileSync(path.join(process.cwd(), 'node_modules', 'whatsapp-web.js', 'package.json'), 'utf8'));
  wwebjsVersion = wwebjsPkg.version;
} catch (e) {
  // Ignore if packages not found
}

logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
logger.info('WhatsApp Web.js Server Starting');
logger.info(`Log Directory: ${logDir || 'Console only (file logging disabled)'}`);
logger.info(`Puppeteer Version: ${puppeteerVersion}`);
logger.info(`WhatsApp-Web.js Version: ${wwebjsVersion}`);
logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

// ==== Global Ä°statistikler ====
global.monitorStats = {
  totalProcessed: 0,
  todayCount: 0,
  errorCount: 0,
  successRate: 100,
  avgTime: 0,
  cacheHits: 0,
  cacheMisses: 0,
  queueLength: 0,
  startTime: Date.now()
};

// GÃ¼nlÃ¼k istatistikleri sÄ±fÄ±rla (her gÃ¼n)
const today = new Date().toDateString();
if (global.lastResetDate !== today) {
  global.monitorStats.todayCount = 0;
  global.lastResetDate = today;
}

// ==== Aktivite Log Sistemi ====
global.activityLogs = [];
const MAX_LOGS = 100;

function addActivityLog(type, message) {
  const log = {
    time: new Date().toLocaleTimeString('tr-TR'),
    type: type,
    message: message,
    timestamp: Date.now()
  };

  global.activityLogs.unshift(log);

  if (global.activityLogs.length > MAX_LOGS) {
    global.activityLogs = global.activityLogs.slice(0, MAX_LOGS);
  }

  logger.info(`[${log.type.toUpperCase()}] ${log.message}`);
}

// ==== Basit yapÄ±landÄ±rmalar ====
const PORT = Number(process.env.PORT) || 3001;
// Base path for reverse proxy support (e.g., "/whatsapp-web" or "" for direct access)
const BASE_PATH = process.env.BASE_PATH || '';
// Cross-platform temp directory
const TMP_DIR = process.env.TMPDIR || os.tmpdir();
// Gallery upload tmp folder inside repository (persistent between runs)
const GALLERY_TMP = path.join(process.cwd(), 'whatsapp_web_js', 'tmp_videos');
if (!fs.existsSync(GALLERY_TMP)) {
  fs.mkdirSync(GALLERY_TMP, { recursive: true });
}
// Chrome path artÄ±k kullanÄ±lmÄ±yor - Puppeteer otomatik olarak Chrome/Edge bulacak
// Manuel path gerekirse: PUPPETEER_EXECUTABLE_PATH env var ile override edilebilir

// ngrok public URL (baÅŸlatÄ±lÄ±nca atanacak)
let TUNNEL_URL = null;

async function startTunnel() {
  try {
    // Dinamik import: @ngrok/ngrok modÃ¼lÃ¼ - yeni API
    const ngrok = await import('@ngrok/ngrok');
    const token = process.env.NGROK_AUTH_TOKEN || process.env.NGROK_TOKEN;

    // Yeni API: forward ile tunnel oluÅŸtur
    const listener = await ngrok.forward({
      addr: PORT,
      authtoken: token
    });

    TUNNEL_URL = listener.url();
    logger.info(`[TUNNEL] ngrok started: ${TUNNEL_URL}`);
    logger.info(`[TUNNEL] Public URL: ${TUNNEL_URL}`);
    logger.info(`[TUNNEL] Local URL:  http://localhost:${PORT}`);
  } catch (e) {
    console.warn("[TUNNEL] ngrok not available or failed:", e?.message || e);
  }
}

// Body parser middleware - multipart/form-data HARÄ°Ã‡ tÃ¼m tipler iÃ§in
app.use((req, res, next) => {
  const contentType = req.get('content-type') || '';
  // EÄŸer multipart/form-data ise, body parser'larÄ± atla
  if (contentType.startsWith('multipart/form-data')) {
    console.log('[MIDDLEWARE] Multipart request detected, skipping body parsers');
    return next();
  }
  next();
});

app.use(express.json({ limit: "100mb" }));
app.use(express.urlencoded({ limit: "100mb", extended: true }));
app.use(express.raw({ limit: "100mb", type: 'application/octet-stream' }));
app.use(express.static("."));

// ==== Multer yapÄ±landÄ±rmasÄ± (dosya upload) ====
const upload = multer({
  dest: TMP_DIR,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB
    files: 5
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('video/')) {
      cb(null, true);
    } else {
      cb(new Error('Sadece video dosyalarÄ± desteklenir!'), false);
    }
  }
});

// Multer instance that stores uploaded gallery videos into repository tmp_videos
const galleryStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, GALLERY_TMP);
  },
  filename: function (req, file, cb) {
    const ext = path.extname(file.originalname) || '.mp4';
    const name = `gallery_${Date.now()}_${Math.random().toString(36).slice(2, 9)}${ext}`;
    cb(null, name);
  }
});

const galleryUpload = multer({
  storage: galleryStorage,
  limits: {
    fileSize: 50 * 1024 * 1024,
    files: 5
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype && file.mimetype.startsWith('video/')) {
      cb(null, true);
    } else {
      cb(new Error('Sadece video dosyalarÄ± desteklenir!'), false);
    }
  }
});

// ==== KiÅŸi yÃ¶netimi iÃ§in helper fonksiyonlar ====
const CONTACTS_FILE = path.join(process.cwd(), "contacts.json");
const COUNTRIES_FILE = path.join(process.cwd(), "countries.json");
const GROUPS_FILE = path.join(process.cwd(), "groups.json");

function loadCountries() {
  try {
    if (fs.existsSync(COUNTRIES_FILE)) {
      const data = fs.readFileSync(COUNTRIES_FILE, "utf8");
      return JSON.parse(data);
    }
  } catch (error) {
    console.error("Countries dosyasÄ± yÃ¼klenemedi:", error.message);
  }
  return { countries: {}, groups: {} };
}

function detectCountryFromPhone(phoneNumber) {
  const countriesData = loadCountries();
  const countries = countriesData.countries;

  // Telefon numarasÄ±nÄ± temizle - sadece rakamlar
  const cleanPhone = phoneNumber.toString().replace(/[^\d]/g, '');

  // Telefon numarasÄ±ndan Ã¼lke kodunu tespit et
  for (const [countryCode, countryInfo] of Object.entries(countries)) {
    if (countryInfo.prefixes && countryInfo.prefixes.length > 0) {
      for (const prefix of countryInfo.prefixes) {
        if (cleanPhone.startsWith(prefix)) {
          return {
            country: countryCode,
            language: countryInfo.language,
            countryName: countryInfo.name,
            flag: countryInfo.flag
          };
        }
      }
    }
  }

  // Bilinmeyen Ã¼lke iÃ§in UNKNOWN dÃ¶ndÃ¼r
  return {
    country: 'UNKNOWN',
    language: 'en',
    countryName: 'Bilinmeyen Ãœlke',
    flag: 'ğŸŒ'
  };
}

function loadContacts() {
  try {
    if (fs.existsSync(CONTACTS_FILE)) {
      const data = fs.readFileSync(CONTACTS_FILE, "utf8");
      return JSON.parse(data);
    }
  } catch (error) {
    console.error("Contacts dosyasÄ± yÃ¼klenemedi:", error.message);
  }

  // VarsayÄ±lan yapÄ±
  return {
    version: "1.0",
    lastUpdated: new Date().toISOString(),
    settings: { defaultLanguage: "tr", enabledLanguages: ["tr", "en", "ru", "ar"] },
    countries: {},
    contacts: [],
    messageTemplates: {}
  };
}

function saveContacts(contactsData) {
  try {
    contactsData.lastUpdated = new Date().toISOString();
    fs.writeFileSync(CONTACTS_FILE, JSON.stringify(contactsData, null, 2), "utf8");
    return true;
  } catch (error) {
    console.error("Contacts dosyasÄ± kaydedilemedi:", error.message);
    return false;
  }
}

// ==== Grup yÃ¶netimi iÃ§in helper fonksiyonlar ====
function loadGroups() {
  try {
    if (fs.existsSync(GROUPS_FILE)) {
      const data = fs.readFileSync(GROUPS_FILE, "utf8");
      return JSON.parse(data);
    }
  } catch (error) {
    console.error("Groups dosyasÄ± yÃ¼klenemedi:", error.message);
  }

  // VarsayÄ±lan yapÄ±
  return {
    version: "1.0",
    lastUpdated: new Date().toISOString(),
    groups: []
  };
}

function saveGroups(groupsData) {
  try {
    groupsData.lastUpdated = new Date().toISOString();
    fs.writeFileSync(GROUPS_FILE, JSON.stringify(groupsData, null, 2), "utf8");
    return true;
  } catch (error) {
    console.error("Groups dosyasÄ± kaydedilemedi:", error.message);
    return false;
  }
}

// ==== Global durum ====
let lastQrString = null;
let ready = false;
const QUEUE = [];
let busy = false;

// ==== Video gruplama sistemi - BATCH MANTIK ====
const batchState = new Map(); // batchId -> { currentContactIndex, batchSize, isComplete, videoCount }
const batchVideos = new Map(); // batchId -> { videos: [{url, caption}], size, fanoutDone }
const batchFiles = new Map(); // batchId -> { files: [{path, caption}], size, fanoutDone }
function getContactsForBatch(batchId, batchSize, totalContacts) {
  // GÃ¼venlik: 0 kiÅŸi varsa fallback
  if (!totalContacts || totalContacts < 1) {
    return {
      contactIndex: 0,
      batchId,
      isNewBatch: true,
      videoInCurrentBatch: 1
    };
  }

  if (!batchState.has(batchId)) {
    batchState.set(batchId, {
      currentContactIndex: 0,   // Bu batch o an hangi kiÅŸide
      batchSize: Number(batchSize) || 1,
      isComplete: false,
      videoCount: 0             // Bu kiÅŸiye gÃ¶nderilen video sayacÄ±
    });
  }

  const state = batchState.get(batchId);

  // GÃ¼venlik: currentContactIndex sÄ±nÄ±r iÃ§inde kalsÄ±n
  if (state.currentContactIndex >= totalContacts) {
    state.currentContactIndex = 0;
  }

  // Bu batch boyunca daima aynÄ± kiÅŸi
  const contactIndex = state.currentContactIndex;

  // Bu kiÅŸiye gÃ¶nderilen video sayÄ±sÄ±nÄ± artÄ±r (1..batchSize)
  state.videoCount++;
  const videoInCurrentBatch = state.videoCount;

  return {
    contactIndex,
    batchId,
    isNewBatch: videoInCurrentBatch === 1,
    videoInCurrentBatch
  };
}

function markBatchComplete(batchId, totalContacts) {
  if (!batchState.has(batchId)) return;
  if (!totalContacts || totalContacts < 1) return;

  const state = batchState.get(batchId);

  // Bu kiÅŸi iÃ§in batch bitti â†’ sÄ±radaki kiÅŸiye geÃ§
  state.currentContactIndex = (state.currentContactIndex + 1) % totalContacts;

  // Yeni kiÅŸi iÃ§in sayaÃ§ sÄ±fÄ±rlanÄ±r
  state.videoCount = 0;

  // TÃ¼m kiÅŸiler tamamlandÄ±ysa iÅŸaretle (baÅŸladÄ±ÄŸÄ±mÄ±z kiÅŸiye geri dÃ¶ndÃ¼k)
  if (state.currentContactIndex === 0) {
    state.isComplete = true;
  }

  batchState.set(batchId, state);
  console.log(`[BATCH] KiÅŸi ${state.currentContactIndex + 1} iÃ§in batch hazÄ±rlanÄ±yor (${batchId})`);
}

// ==== Video Cache Sistemi (AKILLI SÄ°STEM) ====
const videoCache = new Map(); // URL/FileName -> { filePath, downloadTime, useCount, size }

// Upload edilen dosyalarÄ± cache'e ekle
function addFileToCache(fileName, filePath, fileSize) {
  const cacheKey = `file:${fileName}`; // Dosyalar iÃ§in Ã¶zel key

  if (videoCache.has(cacheKey)) {
    const cached = videoCache.get(cacheKey);
    cached.useCount++;
    cached.lastUsed = Date.now();
    global.monitorStats.cacheHits++;
    console.log(`[FILE CACHE HIT] ${fileName} (${cached.useCount}. kullanÄ±m)`);
    return cached.filePath;
  }

  // Yeni dosyayÄ± cache'e ekle
  videoCache.set(cacheKey, {
    filePath: filePath,
    downloadTime: 0, // Upload iÃ§in download time yok
    downloadedAt: Date.now(),
    lastUsed: Date.now(),
    useCount: 1,
    size: fileSize,
    isUpload: true
  });

  global.monitorStats.cacheMisses++;
  console.log(`[FILE CACHE ADD] ${fileName} â†’ cache'e eklendi`);
  addActivityLog('info', `Upload: ${fileName} cache'e eklendi`);

  return filePath;
}

async function getOrCacheVideo(videoUrl) {
  // Cache'de varsa direkt dÃ¶n
  if (videoCache.has(videoUrl)) {
    const cached = videoCache.get(videoUrl);
    cached.useCount++;
    cached.lastUsed = Date.now();

    // Ä°statistikleri gÃ¼ncelle
    global.monitorStats.cacheHits++;

    const message = `Cache hit: ${path.basename(cached.filePath)} (${cached.useCount}. kullanÄ±m)`;
    console.log(`[CACHE HIT] ${message}`);
    addActivityLog('info', message);

    return cached.filePath;
  }

  // Yeni video download et
  const tmpFile = path.join(TMP_DIR, `cached_${Date.now()}_${Math.random().toString(36).substring(7)}.mp4`);

  // Ä°statistikleri gÃ¼ncelle
  global.monitorStats.cacheMisses++;

  addActivityLog('info', `Video indiriliyor: ${path.basename(videoUrl)}`);
  console.log(`[CACHE MISS] Video download ediliyor: ${videoUrl}`);

  const startTime = Date.now();
  const resp = await fetch(videoUrl);
  if (!resp.ok || !resp.body) throw new Error(`Video indirilemedi: HTTP ${resp.status}`);

  await streamPipeline(resp.body, fs.createWriteStream(tmpFile));
  const downloadTime = Date.now() - startTime;
  const fileStats = fs.statSync(tmpFile);

  // Cache'e ekle
  videoCache.set(videoUrl, {
    filePath: tmpFile,
    downloadTime,
    downloadedAt: Date.now(),
    lastUsed: Date.now(),
    useCount: 1,
    size: fileStats.size,
    url: videoUrl
  });

  const sizeMB = Math.round(fileStats.size / 1024 / 1024 * 100) / 100;
  const message = `Yeni video cache'lendi: ${path.basename(tmpFile)} (${sizeMB}MB)`;
  console.log(`[CACHE STORE] ${message}`);
  addActivityLog('info', message);

  return tmpFile;
}

// KUYRUK BÄ°TÄ°NCE CACHE TEMÄ°ZLE - SADECE GERÃ‡EKTEN BÄ°TÄ°NCE
function clearAllCache() {
  const cacheCount = videoCache.size;
  console.log(`[CACHE CLEAR] ${cacheCount} cache dosyasÄ± temizleniyor...`);

  if (cacheCount > 0) {
    addActivityLog('info', `${cacheCount} cache dosyasÄ± temizleniyor`);
  }

  for (const [url, cache] of videoCache.entries()) {
    try {
      fs.unlinkSync(cache.filePath);
      console.log(`[CACHE CLEAR] Cache dosyasÄ± silindi: ${path.basename(cache.filePath)} (${cache.useCount} kullanÄ±m)`);
    } catch (err) {
      console.log(`[CACHE CLEAR] Dosya silinemedi: ${err.message}`);
    }
  }

  videoCache.clear();

  // Tamamlanan batch state'lerini temizle
  const completedBatches = [];
  for (const [batchId, state] of batchState.entries()) {
    if (state.isComplete) {
      completedBatches.push(batchId);
    }
  }

  for (const batchId of completedBatches) {
    batchState.delete(batchId);
  }

  console.log(`[CACHE CLEAR] TÃ¼m cache temizlendi.`);
  if (completedBatches.length > 0) {
    console.log(`[STATE CLEAR] ${completedBatches.length} tamamlanan batch state'i temizlendi.`);
    addActivityLog('info', `Tamamlanan batch state'leri temizlendi (${completedBatches.length} batch)`);
  }

  // Galeriden yÃ¼klenen dosyalarÄ± da temizle
  for (const [bId, reg] of batchFiles.entries()) {
    try {
      const files = (reg?.files || []).filter(Boolean);
      for (const f of files) {
        if (fs.existsSync(f)) {
          fs.unlinkSync(f);
          console.log(`[CACHE CLEAR] Gallery file silindi: ${path.basename(f)}`);
        }
      }
    } catch (e) {
      console.log(`[CACHE CLEAR] Gallery file silinemedi: ${e.message}`);
    }
  }
  batchFiles.clear();

}

// ==== Chromium Auto-Download Check ====
// ==== Chromium Auto-Download Check ====
async function ensureChromium() {
  try {
    const puppeteer = await import('puppeteer');
    const browserFetcher = puppeteer.createBrowserFetcher(); // FIX: .default kaldÄ±r
    const revisionInfo = browserFetcher.revisionInfo(puppeteer.chromium.revision);
    if (!revisionInfo.local) {
      console.log('[CHROMIUM] Chromium not found, downloading...');
      console.log(`[CHROMIUM] Platform: ${process.platform}`);
      console.log(`[CHROMIUM] Revision: ${puppeteer.chromium.revision}`);
      await browserFetcher.download(puppeteer.chromium.revision, (downloadedBytes, totalBytes) => {
        const percent = ((downloadedBytes / totalBytes) * 100).toFixed(2);
        process.stdout.write(`\r[CHROMIUM] Downloading: ${percent}%`);
      });
      console.log('\n[CHROMIUM] âœ… Chromium downloaded successfully!');
    } else {
      console.log('[CHROMIUM] âœ… Chromium already exists:', revisionInfo.executablePath);
    }
  } catch (error) {
    console.warn('[CHROMIUM] âš ï¸ Auto-download failed:', error.message);
    console.warn('[CHROMIUM] Will try to use system Chrome/Edge...');
  }
}

// Chromium kontrolÃ¼nÃ¼ baÅŸlangÄ±Ã§ta yap
await ensureChromium();

// ==== Chrome/Edge Path Detection (Windows Uyumlu) ====
function findBrowserExecutable() {
  // 1. Ã–nce environment variable kontrol et
  if (process.env.PUPPETEER_EXECUTABLE_PATH) {
    if (fs.existsSync(process.env.PUPPETEER_EXECUTABLE_PATH)) {
      logger.info(`[BROWSER] Using environment variable: ${process.env.PUPPETEER_EXECUTABLE_PATH}`);
      return process.env.PUPPETEER_EXECUTABLE_PATH;
    }
  }

  // 2. Windows iÃ§in yaygÄ±n Chrome/Edge yollarÄ±
  const windowsPaths = [
    "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
    "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",
    "C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe",
    "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"
  ];

  // 3. macOS iÃ§in yaygÄ±n Chrome yollarÄ±
  const macPaths = [
    "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
    "/Applications/Chromium.app/Contents/MacOS/Chromium",
    "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge"
  ];

  // 4. Linux iÃ§in yaygÄ±n Chrome yollarÄ±
  const linuxPaths = [
    "/usr/bin/google-chrome",
    "/usr/bin/google-chrome-stable",
    "/usr/bin/chromium",
    "/usr/bin/chromium-browser",
    "/snap/bin/chromium"
  ];

  const platformPaths =
    process.platform === "win32" ? windowsPaths :
      process.platform === "darwin" ? macPaths :
        linuxPaths;

  for (const browserPath of platformPaths) {
    if (fs.existsSync(browserPath)) {
      logger.info(`[BROWSER] Found browser at: ${browserPath}`);
      return browserPath;
    }
  }

  // 5. BulunamadÄ± - Puppeteer kendi yÃ¼klediÄŸini kullansÄ±n (varsa)
  logger.warn("[BROWSER] No system browser found. Puppeteer will try to use its own Chromium.");
  return undefined;
}

const browserExecutablePath = findBrowserExecutable();

// ==== WhatsApp Client (1.34.1) ====
const client = new Client({
  // Session dosyalarÄ±nÄ± ./wweb-session altÄ±nda tut (LocalAuth docs)
  authStrategy: new LocalAuth({ dataPath: "./wweb-session" }),
  puppeteer: {
    headless: true,
    // Sistemdeki Chrome/Edge'i kullan (Windows uyumlu)
    ...(browserExecutablePath && { executablePath: browserExecutablePath }),
    args: [
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--disable-dev-shm-usage",
      "--disable-gpu"
    ]
  }
});

client.on("qr", (qr) => {
  lastQrString = qr;
  ready = false;
  console.log(`[QR] Yeni QR Ã¼retildi â†’ http://localhost:${PORT} Ã¼zerinden okutun.`);
});

client.on("ready", async () => {
  ready = true;
  lastQrString = null;
  console.log("[READY] WhatsApp oturumu aktif.");

  // Log Chromium version
  try {
    const browser = await client.pupPage.browser();
    const version = await browser.version();
    logger.info(`[READY] Chromium/Browser Version: ${version}`);
  } catch (e) {
    logger.warn('[READY] Could not retrieve browser version', { error: e.message });
  }
});

client.on("disconnected", (reason) => {
  ready = false;
  console.error("[DISCONNECTED]", reason);
  // Lokal kullanÄ±mda proses aÃ§Ä±k kalsÄ±n; istersen burada exit/auto-restart kurabilirsin.
});

client.initialize();

// ==== Kuyruk iÅŸÃ§isi (tek eÅŸzamanlÄ± - URL ve dosya desteÄŸi + CACHE + BATCH) ====
async function worker() {
  // Log worker state
  if (busy) {
    logger.debug('[WORKER] Worker busy, skipping');
    return;
  }
  if (QUEUE.length === 0) {
    logger.debug('[WORKER] Queue empty, skipping');
    return;
  }
  if (!ready) {
    logger.warn('[WORKER] WhatsApp not ready, cannot process queue');
    logEndpoint('worker', 'INTERNAL', { queueLength: QUEUE.length }, { error: 'WhatsApp not ready' });
    return;
  }

  busy = true;
  const job = QUEUE.shift();
  const {
    to,
    caption,
    videoUrl,
    videoFilePath,
    isFileUpload,
    useCache = true,
    isBatchOperation = false,
    contactName,
    videoInSet,
    totalInSet,
    type = 'contact' // 'contact' veya 'group'
  } = job;

  // Log job start
  const jobStartTime = Date.now();
  logger.info('[WORKER] Processing job', {
    to,
    videoUrl: videoUrl || 'N/A',
    videoFilePath: videoFilePath || 'N/A',
    isFileUpload,
    useCache,
    isBatchOperation,
    contactName: contactName || 'N/A',
    videoInSet: videoInSet || 'N/A',
    totalInSet: totalInSet || 'N/A',
    queueLength: QUEUE.length,
    ready
  });
  logEndpoint('worker', 'INTERNAL', { to, videoUrl, isFileUpload, isBatchOperation }, 'started');

  // Kuyruk durumu logu
  if (QUEUE.length > 0) {
    addActivityLog('warning', `Kuyrukta ${QUEUE.length} iÅŸlem bekliyor`);
  }

  let tmpFile = null;
  let isFromCache = false;

  try {
    // BATCH Ä°ÅLEM LOGU
    if (isBatchOperation && contactName) {
      console.log(`[BATCH WORKER] ${contactName}: Video ${videoInSet}/${totalInSet} gÃ¶nderiliyor...`);
    }

    if (isFileUpload && videoFilePath) {
      // Gallery'den gelen dosya upload'u - dosya zaten TMP_DIR iÃ§inde
      tmpFile = videoFilePath;
      console.log(`[WORKER] Gallery dosyasÄ± iÅŸleniyor: ${path.basename(tmpFile)} â†’ ${to}`);
    } else if (videoUrl) {
      if (useCache) {
        // CACHE SÄ°STEMÄ°: AynÄ± videoyu tekrar download etme
        tmpFile = await getOrCacheVideo(videoUrl);
        isFromCache = true;
        const logMsg = isBatchOperation ?
          `[BATCH WORKER] Cache video: ${path.basename(tmpFile)} â†’ ${contactName}` :
          `[WORKER] Cache video kullanÄ±lÄ±yor: ${path.basename(tmpFile)} â†’ ${to}`;
        console.log(logMsg);
      } else {
        // ESKÄ° SÄ°STEM: Her seferinde download et
        tmpFile = path.join(TMP_DIR, `wa_${Date.now()}.mp4`);
        console.log(`[WORKER] URL stream ediliyor: ${videoUrl} â†’ ${to}`);

        const resp = await fetch(videoUrl);
        if (!resp.ok || !resp.body) throw new Error(`Video indirilemedi: HTTP ${resp.status}`);
        await streamPipeline(resp.body, fs.createWriteStream(tmpFile));
      }
    } else {
      throw new Error("Video URL veya dosya yolu gerekli");
    }

    // Dosyadan medya oluÅŸtur (MessageMedia.fromFilePath â€” 1.34.1)
    const media = MessageMedia.fromFilePath(tmpFile);

    // Video gÃ¶nderme - grup vs kiÅŸi ayrÄ±mÄ±
    if (type === 'group') {
      // GRUP GÃ–NDERÄ°MÄ° - toUserWidOrThrow hatasÄ±nÄ± Ã¶nlemek iÃ§in getChatById() kullan
      logger.info('[WORKER-GROUP] Sending video to group', { groupId: to, hasCaption: !!caption });

      try {
        // Ã–nce chat objesini al
        const chat = await client.getChatById(to);

        // Grup kontrolÃ¼
        if (!chat.isGroup) {
          throw new Error(`${to} bir grup deÄŸil!`);
        }

        // Admin kontrolÃ¼ (varsa)
        if (chat.groupMetadata && chat.groupMetadata.announce) {
          // Sadece adminler mesaj atabilir modu aÃ§Ä±k
          const myId = client.info.wid._serialized;
          const isAdmin = chat.groupMetadata.participants.some(
            p => p.id._serialized === myId && (p.isAdmin || p.isSuperAdmin)
          );

          if (!isAdmin) {
            throw new Error(`[GROUP-PERMISSION] Grupta admin deÄŸilsiniz: ${contactName || to}`);
          }
        }

        // Grup'a video gÃ¶nder (chat.sendMessage daha stabil)
        await chat.sendMessage(media, { caption: caption || "" });
        logger.info('[WORKER-GROUP] Video sent to group successfully', { groupId: to, groupName: chat.name });

      } catch (groupError) {
        logger.error('[WORKER-GROUP] Group send failed', {
          error: groupError.message,
          groupId: to,
          contactName: contactName || 'N/A'
        });
        throw groupError;
      }

    } else {
      // KÄ°ÅÄ° GÃ–NDERÄ°MÄ° - Normal flow
      const jid = `${to}@c.us`; // bireysel kiÅŸi
      logger.info('[WORKER-CONTACT] Sending video to contact', { jid, hasCaption: !!caption });
      await client.sendMessage(jid, media, {
        caption: caption || ""
        // sendMediaAsDocument: false (varsayÄ±lan) - video olarak gÃ¶nder
      });
      logger.info('[WORKER-CONTACT] Video sent successfully', { jid });
    }

    // BaÅŸarÄ±lÄ± gÃ¶nderim logu
    const processingTime = Date.now() - jobStartTime;
    if (isBatchOperation && contactName) {
      const successMessage = `${contactName}: Video ${videoInSet}/${totalInSet} baÅŸarÄ±yla gÃ¶nderildi`;
      console.log(`[BATCH OK] ${successMessage}`);
      addActivityLog('success', successMessage);
      logger.info('[WORKER] Batch video sent', { contactName, videoInSet, totalInSet, processingTime });
    } else {
      const successMessage = `Video baÅŸarÄ±yla gÃ¶nderildi: ${to}`;
      console.log(`[OK] ${successMessage} - ${isFileUpload ? 'Gallery dosyasÄ±' : isFromCache ? 'Cache video' : 'URL stream'}`);
      addActivityLog('success', successMessage);
      logger.info('[WORKER] Video sent', { to, isFileUpload, isFromCache, processingTime });
    }

    // Log success to endpoints.log
    logEndpoint('worker', 'INTERNAL', { to, videoUrl, isFileUpload, isBatchOperation }, {
      success: true,
      processingTime,
      queueLength: QUEUE.length,
      method: isFileUpload ? 'gallery' : isFromCache ? 'cache' : 'stream'
    });

    // Ä°statistikleri gÃ¼ncelle
    global.monitorStats.totalProcessed++;
    global.monitorStats.todayCount++;

    await new Promise((r) => setTimeout(r, 2000)); // anti-spam tamponu (2sn)

  } catch (err) {
    // Hata logu
    const processingTime = Date.now() - jobStartTime;
    logger.error('[WORKER] Failed to send video', {
      error: err.message,
      stack: err.stack,
      to,
      videoUrl,
      videoFilePath,
      isFileUpload,
      isBatchOperation,
      contactName,
      processingTime
    });

    if (isBatchOperation && contactName) {
      const errorMessage = `${contactName}: Video ${videoInSet}/${totalInSet} gÃ¶nderilemedi - ${err.message}`;
      console.error(`[BATCH HATA] ${errorMessage}`);
      addActivityLog('error', errorMessage);
    } else {
      const errorMessage = `Video gÃ¶nderilemedi: ${to} - ${err.message}`;
      console.error(`[HATA] ${errorMessage}`);
      addActivityLog('error', errorMessage);
    }

    // Log error to endpoints.log
    logEndpoint('worker', 'INTERNAL', { to, videoUrl, isFileUpload, isBatchOperation }, {
      success: false,
      error: err.message,
      stack: err.stack,
      processingTime
    });

    // Hata istatistiklerini gÃ¼ncelle
    global.monitorStats.errorCount++;
  } finally {
    // GeÃ§ici dosyayÄ± temizle (SADECE cache olmayan dosyalar)
    if (tmpFile && !isFromCache && !isFileUpload) {
      try {
        fs.existsSync(tmpFile) && fs.unlinkSync(tmpFile);
        console.log(`[CLEANUP] GeÃ§ici dosya silindi: ${path.basename(tmpFile)}`);
      } catch (cleanupErr) {
        console.log(`[CLEANUP] Dosya silinemedi: ${cleanupErr.message}`);
      }
    }

    busy = false;

    // KUYRUK BÄ°TTÄ°YSE CACHE'Ä° TEMÄ°ZLE - SADECE BATCH TAMAMEN BÄ°TTÄ°YSE
    if (QUEUE.length === 0) {
      console.log(`[QUEUE] Kuyruk boÅŸ, batch durumu kontrol ediliyor...`);

      // Aktif batch'ler var mÄ± kontrol et
      let hasActiveBatches = false;
      for (const [batchId, state] of batchState.entries()) {
        if (!state.isComplete) {
          console.log(`[QUEUE] Batch ${batchId} henÃ¼z devam ediyor, cache korunuyor...`);
          hasActiveBatches = true;
          break;
        }
      }

      // Sadece tÃ¼m batch'ler tamamlandÄ±ysa cache'i temizle
      if (!hasActiveBatches && batchState.size > 0) {
        console.log(`[QUEUE] TÃ¼m batch'ler tamamlandÄ±, cache temizleniyor...`);
        clearAllCache();
      } else if (batchState.size === 0) {
        console.log(`[QUEUE] HiÃ§ batch yok, cache temizleniyor...`);
        clearAllCache();
      }
    }

    setImmediate(worker);
  }
}

function enqueue(job) {
  QUEUE.push(job);
  setImmediate(worker);
}

// ==== Basit QR HTML (otomatik yenileme) ====
const HTML_PAGE = `<!doctype html>
<html lang="tr">
<head>
<base href="${BASE_PATH ? BASE_PATH + '/' : '/'}">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WhatsApp Bridge â€” wa-bridge-local</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; margin:0; background:#0f172a; color:#e5e7eb; display:flex; min-height:100vh; align-items:center; justify-content:center; flex-direction:column}
  .nav{position:fixed; top:0; left:0; right:0; background:#111827; padding:16px 24px; display:flex; justify-content:space-between; align-items:center; box-shadow:0 4px 12px rgba(0,0,0,0.3); z-index:1000}
  .nav h1{color:#25D366; font-size:18px; margin:0}
  .nav-menu{display:flex; gap:16px}
  .nav-link{color:#9ca3af; text-decoration:none; padding:8px 16px; border-radius:6px; transition:all 0.3s; font-size:14px; font-weight:500}
  .nav-link:hover{background:#25D366; color:white}
  .nav-link.active{background:#25D366; color:white}
  .card{background:#111827; padding:32px; border-radius:16px; width:min(520px,92vw); box-shadow:0 10px 30px rgba(0,0,0,.35); margin-top:80px}
  h2{font-size:24px;margin:0 0 8px; color:#25D366}
  p{margin:8px 0 0;color:#9ca3af; line-height:1.5}
  .qr{margin-top:24px; background:#fff; padding:16px; border-radius:12px; display:flex; align-items:center; justify-content:center}
  #qr{width:100%; height:auto; border-radius:8px; max-width:300px}
  .status{margin-top:18px; font-size:15px; padding:12px; border-radius:8px; text-align:center}
  .status.ok{background:#064e3b; color:#34d399; border:1px solid #065f46}
  .status.warn{background:#451a03; color:#f59e0b; border:1px solid #92400e}
  .features{margin-top:24px; padding:20px; background:#1f2937; border-radius:12px}
  .features h3{color:#e5e7eb; margin:0 0 12px; font-size:16px}
  .features ul{margin:0; padding-left:20px; color:#9ca3af}
  .features li{margin:6px 0; line-height:1.4}
  .footer{margin-top:24px; text-align:center; font-size:13px; color:#6b7280}

  /* Modal Styles */
  .modal{display:none; position:fixed; z-index:2000; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.7)}
  .modal-content{background:#111827; margin:10% auto; padding:0; width:min(500px,90vw); border-radius:12px; color:#e5e7eb}
  .modal-header{padding:20px; border-bottom:1px solid #374151; display:flex; justify-content:space-between; align-items:center}
  .modal-header h3{margin:0; color:#25D366}
  .close{color:#9ca3af; float:right; font-size:28px; font-weight:bold; cursor:pointer}
  .close:hover{color:#e5e7eb}
  .modal-body{padding:20px}
  .status-info{margin-bottom:20px}
  .status-row{display:flex; justify-content:space-between; margin:10px 0; padding:8px 0; border-bottom:1px solid #374151}
  .status-label{font-weight:500; color:#9ca3af}
  .status-value{color:#e5e7eb}
  .modal-actions{display:flex; gap:10px; justify-content:center}
  .btn{padding:10px 20px; border:none; border-radius:6px; cursor:pointer; font-weight:500; transition:all 0.3s}
  .btn-danger{background:#dc2626; color:white}
  .btn-danger:hover{background:#b91c1c}
  .btn-secondary{background:#6b7280; color:white}
  .btn-secondary:hover{background:#4b5563}
</style>
</head>
<body>
  <nav class="nav">
    <h1>ğŸ“± WhatsApp Bridge</h1>
    <div class="nav-menu">
      <a href="./" class="nav-link active">ğŸ  Ana Sayfa</a>
      <a href="contacts" class="nav-link">ğŸ‘¥ KiÅŸiler</a>
      <a href="monitor" class="nav-link">ğŸ“Š MonitÃ¶r</a>
      <a href="#" class="nav-link" onclick="openStatusModal()">âš¡ Durum</a>
    </div>
  </nav>

  <div class="card">
    <h2>WhatsApp QR BaÄŸlantÄ±sÄ±</h2>
    <p>Telefonunuzda WhatsApp âœ BaÄŸlÄ± cihazlar âœ Cihaz baÄŸla; bu ekrandaki QR'Ä± okutun.</p>
    <div class="qr"><img id="qr" alt="QR Kodu" /></div>
    <div class="status warn" id="status">ğŸ”„ BaÄŸlantÄ± kontrol ediliyor...</div>

    <div class="features">
      <h3>ğŸš€ Ã–zellikler</h3>
      <ul>
        <li>ğŸ“¹ Video gÃ¶nderimi (n8n entegrasyonu)</li>
        <li>ğŸ‘¥ KiÅŸi yÃ¶netimi (Ã¼lke bazlÄ±)</li>
        <li>ğŸŒ Ã‡oklu dil desteÄŸi</li>
        <li>âš¡ Otomatik kuyruk sistemi</li>
        <li>ğŸ“Š CanlÄ± durumu takibi</li>
      </ul>
    </div>

    <div class="footer">
      wa-bridge-local v1.0 â€” Svelto Stella WhatsApp Automation
    </div>
  </div>

  <!-- Status Modal -->
  <div id="statusModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>âš¡ WhatsApp Durum</h3>
        <span class="close" onclick="closeStatusModal()">&times;</span>
      </div>
      <div class="modal-body">
        <div class="status-info">
          <div class="status-row">
            <span class="status-label">BaÄŸlantÄ± Durumu:</span>
            <span id="modalStatus" class="status-value">Kontrol ediliyor...</span>
          </div>
          <div class="status-row">
            <span class="status-label">Son Kontrol:</span>
            <span id="lastCheck" class="status-value">-</span>
          </div>
          <div class="status-row">
            <span class="status-label">Session:</span>
            <span id="sessionInfo" class="status-value">-</span>
          </div>
        </div>
        <div class="modal-actions">
          <button class="btn btn-danger" onclick="clearSession()">
            ğŸ—‘ï¸ Session Temizle & QR Reset
          </button>
          <button class="btn btn-secondary" onclick="logoutWhatsApp()">
            ğŸšª Sadece Ã‡Ä±kÄ±ÅŸ Yap
          </button>
          <button class="btn btn-secondary" onclick="refreshStatus()">
            ğŸ”„ Durumu Yenile
          </button>
        </div>
      </div>
    </div>
  </div>
<script>
// Global BASE_PATH for API calls
window.BASE_PATH = "${BASE_PATH || ''}";

async function refresh(){
  try{
    const s = await fetch("status").then(r=>r.json());
    const statusEl = document.getElementById("status");
    const qrContainer = document.querySelector(".qr");

    if(s.ready){
      statusEl.textContent = "âœ… WhatsApp baÄŸlÄ± ve hazÄ±r!";
      statusEl.className = "status ok";
      qrContainer.style.display = "none"; // QR alanÄ±nÄ± tamamen gizle
      return; // WhatsApp baÄŸlÄ±yken QR isteÄŸi yapma
    }else{
      statusEl.textContent = "âš ï¸ WhatsApp baÄŸlÄ± deÄŸil (QR bekleniyor)";
      statusEl.className = "status warn";
      qrContainer.style.display = "block"; // QR alanÄ±nÄ± gÃ¶ster
      qrContainer.innerHTML = '<img id="qr" alt="QR Kodu" />';

      // Sadece WhatsApp baÄŸlÄ± deÄŸilken QR isteÄŸi yap
      try {
        const q = await fetch("qr").then(r=>r.json());
        const newQrEl = document.getElementById("qr");
        if(newQrEl) newQrEl.src = q.dataUrl || "";
      } catch(qrError) {
        console.log("QR alÄ±namadÄ±:", qrError);
        // QR alÄ±namazsa sessizce devam et
      }
    }
  }catch(e){
    document.getElementById("status").textContent = "âŒ BaÄŸlantÄ± hatasÄ±";
    document.getElementById("status").className = "status warn";
    console.error("Status kontrol hatasÄ±:", e);
  }
}
refresh();
setInterval(refresh, 3000);

// Modal Functions
function openStatusModal() {
  document.getElementById('statusModal').style.display = 'block';
  refreshStatus();
}

function closeStatusModal() {
  document.getElementById('statusModal').style.display = 'none';
}

function refreshStatus() {
  const now = new Date().toLocaleString('tr-TR');
  document.getElementById('lastCheck').textContent = now;

  fetch('status')
    .then(r => r.json())
    .then(s => {
      document.getElementById('modalStatus').textContent = s.ready ? 'âœ… BaÄŸlÄ± ve HazÄ±r' : 'âš ï¸ BaÄŸlÄ± DeÄŸil';
      document.getElementById('sessionInfo').textContent = s.ready ? 'Aktif' : 'Bekleniyor';
    })
    .catch(e => {
      document.getElementById('modalStatus').textContent = 'âŒ Hata';
      document.getElementById('sessionInfo').textContent = 'Bilinmiyor';
    });
}

async function logoutWhatsApp() {
  if (!confirm('âš ï¸ SADECE Ã‡IKIÅ\\n\\nWhatsApp oturumu kapatÄ±lacak ama session dosyalarÄ± korunacak.\\nBu sayede server restart sonrasÄ± tekrar otomatik baÄŸlanabilirsiniz.\\n\\nDevam etmek istediÄŸinizden emin misiniz?')) {
    return;
  }

  try {
    const response = await fetch('logout', { method: 'POST' });
    const result = await response.json();

    if (result.success) {
      alert('âœ… Ã‡Ä±kÄ±ÅŸ iÅŸlemi baÅŸarÄ±lÄ±!\\nSession korundu. Server restart ile tekrar baÄŸlanabilirsiniz.');
      closeStatusModal();
      setTimeout(() => window.location.reload(), 1000);
    } else {
      alert('âŒ Ã‡Ä±kÄ±ÅŸ iÅŸlemi baÅŸarÄ±sÄ±z: ' + result.error);
    }
  } catch (error) {
    alert('âŒ BaÄŸlantÄ± hatasÄ±: ' + error.message);
  }
}

async function clearSession() {
  if (!confirm('âš ï¸ TÃœM SESSION TEMÄ°ZLENECEK!\\n\\nBu iÅŸlem tÃ¼m WhatsApp session dosyalarÄ±nÄ± silecek.\\nYeniden QR kod okutmanÄ±z gerekecek.\\n\\nSadece sorun yaÅŸÄ±yorsanÄ±z kullanÄ±n!\\n\\nDevam etmek istediÄŸinizden emin misiniz?')) {
    return;
  }

  try {
    const response = await fetch('clear-session', { method: 'POST' });
    const result = await response.json();

    if (result.success) {
      alert('âœ… Session temizlendi!\\nSayfa yenilenecek ve yeni QR kod gÃ¶rÃ¼necek.');
      closeStatusModal();
      setTimeout(() => window.location.reload(), 1000);
    } else {
      alert('âŒ Session temizleme baÅŸarÄ±sÄ±z: ' + result.error);
    }
  } catch (error) {
    alert('âŒ BaÄŸlantÄ± hatasÄ±: ' + error.message);
  }
}

// Modal dÄ±ÅŸÄ±na tÄ±klayÄ±nca kapat
window.onclick = function(event) {
  const modal = document.getElementById('statusModal');
  if (event.target === modal) {
    closeStatusModal();
  }
}
</script>
</body>
</html>`;

// ==== Global Request Logger Middleware ====
app.use((req, res, next) => {
  const start = Date.now();
  logger.info(`[REQUEST] ${req.method} ${req.url}`);

  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info(`[RESPONSE] ${req.method} ${req.url} - ${res.statusCode} (${duration}ms)`);
  });

  next();
});

// ==== Rotalar ====
app.get("/", (req, res) => {
  res.set("Content-Type", "text/html; charset=utf-8");
  res.send(HTML_PAGE);
});

// ==== KiÅŸi yÃ¶netimi API'leri ====
// KiÅŸi listesini getir
app.get("/api/contacts", (req, res) => {
  const contactsData = loadContacts();
  res.json(contactsData);
});

// KiÅŸi listesini kaydet
app.post("/api/contacts/save", (req, res) => {
  const startTime = Date.now();
  const { contacts } = req.body || {};
  logEndpoint('/api/contacts/save', 'POST', req.body, 'started');

  if (!Array.isArray(contacts)) {
    const error = { error: "Contacts array gerekli." };
    logger.warn('[CONTACTS-SAVE] Validation failed', { contacts: typeof contacts, error: error.error });
    logEndpoint('/api/contacts/save', 'POST', req.body, { ...error, success: false });
    return res.status(400).json(error);
  }

  const contactsData = loadContacts();
  contactsData.contacts = contacts;

  if (saveContacts(contactsData)) {
    const processingTime = Date.now() - startTime;
    const response = { success: true, count: contacts.length, processingTime };
    logger.info('[CONTACTS-SAVE] Success', { count: contacts.length, processingTime });
    logEndpoint('/api/contacts/save', 'POST', req.body, response);
    res.json(response);
  } else {
    const processingTime = Date.now() - startTime;
    const error = { error: "Kaydetme hatasÄ±.", success: false, processingTime };
    logger.error('[CONTACTS-SAVE] Failed to save', { count: contacts.length, processingTime });
    logEndpoint('/api/contacts/save', 'POST', req.body, error);
    res.status(500).json(error);
  }
});

// KiÅŸi listesini temizle
app.post("/api/contacts/clear", (req, res) => {
  const startTime = Date.now();
  logEndpoint('/api/contacts/clear', 'POST', req.body, 'started');

  try {
    const contactsData = loadContacts();
    const previousCount = contactsData.contacts.length;
    contactsData.contacts = [];
    contactsData.lastUpdated = new Date().toISOString();

    if (saveContacts(contactsData)) {
      const processingTime = Date.now() - startTime;
      const response = { success: true, message: "TÃ¼m kiÅŸiler baÅŸarÄ±yla silindi.", previousCount, processingTime };
      logger.info('[CONTACTS-CLEAR] Success', { previousCount, processingTime });
      logEndpoint('/api/contacts/clear', 'POST', req.body, response);
      res.json(response);
    } else {
      const processingTime = Date.now() - startTime;
      const error = { error: "Temizleme sÄ±rasÄ±nda hata oluÅŸtu.", success: false, processingTime };
      logger.error('[CONTACTS-CLEAR] Failed to save', { previousCount, processingTime });
      logEndpoint('/api/contacts/clear', 'POST', req.body, error);
      res.status(500).json(error);
    }
  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error('[CONTACTS-CLEAR] Exception', { error: error.message, stack: error.stack, processingTime });
    logEndpoint('/api/contacts/clear', 'POST', req.body, { error: error.message, success: false, processingTime });
    res.status(500).json({ error: "Temizleme sÄ±rasÄ±nda hata oluÅŸtu." });
  }
});

// Ãœlke bazlÄ± aktif kiÅŸileri getir
app.get("/api/contacts/active", (req, res) => {
  const { country, language } = req.query;
  const contactsData = loadContacts();

  let activeContacts = contactsData.contacts.filter(c => c.active);

  if (country) {
    activeContacts = activeContacts.filter(c => c.country === country.toUpperCase());
  }

  if (language) {
    activeContacts = activeContacts.filter(c => c.language === language.toLowerCase());
  }

  res.json({
    contacts: activeContacts,
    count: activeContacts.length,
    countries: contactsData.countries
  });
});

// ========================================
// GROUPS API ENDPOINTS
// ========================================

// Grup listesini getir
app.get("/api/groups", (req, res) => {
  const groupsData = loadGroups();
  res.json(groupsData);
});

// Grup listesini kaydet
app.post("/api/groups/save", (req, res) => {
  const startTime = Date.now();
  const { groups } = req.body || {};
  logEndpoint('/api/groups/save', 'POST', req.body, 'started');

  if (!Array.isArray(groups)) {
    const error = { error: "Groups array gerekli." };
    logger.warn('[GROUPS-SAVE] Validation failed', { groups: typeof groups, error: error.error });
    logEndpoint('/api/groups/save', 'POST', req.body, { ...error, success: false });
    return res.status(400).json(error);
  }

  const groupsData = loadGroups();
  groupsData.groups = groups;

  if (saveGroups(groupsData)) {
    const processingTime = Date.now() - startTime;
    const response = { success: true, count: groups.length, processingTime };
    logger.info('[GROUPS-SAVE] Success', { count: groups.length, processingTime });
    logEndpoint('/api/groups/save', 'POST', req.body, response);
    res.json(response);
  } else {
    const processingTime = Date.now() - startTime;
    const error = { error: "Kaydetme hatasÄ±.", success: false, processingTime };
    logger.error('[GROUPS-SAVE] Failed to save', { count: groups.length, processingTime });
    logEndpoint('/api/groups/save', 'POST', req.body, error);
    res.status(500).json(error);
  }
});

// Grup listesini temizle
app.post("/api/groups/clear", (req, res) => {
  const startTime = Date.now();
  logEndpoint('/api/groups/clear', 'POST', req.body, 'started');

  try {
    const groupsData = loadGroups();
    const previousCount = groupsData.groups.length;
    groupsData.groups = [];
    groupsData.lastUpdated = new Date().toISOString();

    if (saveGroups(groupsData)) {
      const processingTime = Date.now() - startTime;
      const response = { success: true, message: "TÃ¼m gruplar baÅŸarÄ±yla silindi.", previousCount, processingTime };
      logger.info('[GROUPS-CLEAR] Success', { previousCount, processingTime });
      logEndpoint('/api/groups/clear', 'POST', req.body, response);
      res.json(response);
    } else {
      const processingTime = Date.now() - startTime;
      const error = { error: "Temizleme sÄ±rasÄ±nda hata oluÅŸtu.", success: false, processingTime };
      logger.error('[GROUPS-CLEAR] Failed to save', { previousCount, processingTime });
      logEndpoint('/api/groups/clear', 'POST', req.body, error);
      res.status(500).json(error);
    }
  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error('[GROUPS-CLEAR] Exception', { error: error.message, stack: error.stack, processingTime });
    logEndpoint('/api/groups/clear', 'POST', req.body, { error: error.message, success: false, processingTime });
    res.status(500).json({ error: "Temizleme sÄ±rasÄ±nda hata oluÅŸtu." });
  }
});

// Aktif gruplarÄ± getir
app.get("/api/groups/active", (req, res) => {
  const groupsData = loadGroups();
  const activeGroups = groupsData.groups.filter(g => g.isActive);

  res.json({
    groups: activeGroups,
    count: activeGroups.length
  });
});

// Dil bazlÄ± mesaj template'leri getir
app.get("/api/templates/:language", (req, res) => {
  const { language } = req.params;
  const contactsData = loadContacts();

  const template = contactsData.messageTemplates[language];
  if (!template) {
    return res.status(404).json({ error: "Template bulunamadÄ±." });
  }

  res.json(template);
});

// KiÅŸi yÃ¶netim sayfasÄ±
app.get("/contacts", (req, res) => {
  // CSP header ekle - blob: URL'leri ve media'ya izin ver
  res.setHeader(
    'Content-Security-Policy',
    "script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; media-src 'self' blob: data:; connect-src 'self'; font-src 'self'; object-src 'none'; base-uri 'self'"
  );

  const contactsPath = path.join(process.cwd(), "contacts.html");
  if (fs.existsSync(contactsPath)) {
    let html = fs.readFileSync(contactsPath, 'utf-8');

    // Inject base tag after <head>
    const baseTag = `<base href="${BASE_PATH ? BASE_PATH + '/' : '/'}">`;
    html = html.replace('<head>', `<head>\n    ${baseTag}`);

    // Inject BASE_PATH and fetch wrapper before first <script>
    const basePathScript = `<script>
      window.BASE_PATH = "${BASE_PATH || ''}";
      // Wrapper for fetch to handle BASE_PATH automatically
      window._fetch = window.fetch;
      window.fetch = function(url, ...args) {
        if (typeof url === 'string' && url.startsWith('/') && !url.startsWith('//')) {
          // Skip BASE_PATH only for /assets/ (CSS, JS) - .json files need BASE_PATH
          if (!url.startsWith('/assets/')) {
            url = window.BASE_PATH + url;
          }
        }
        return window._fetch(url, ...args);
      };
    </script>`;
    html = html.replace('<script', `${basePathScript}\n    <script`);

    // Fix absolute paths to relative
    html = html.replace(/href="\/"/g, 'href="./"');
    html = html.replace(/href="\/monitor"/g, 'href="monitor"');
    html = html.replace(/href="\/contacts"/g, 'href="contacts"');
    html = html.replace(/href="\/groups"/g, 'href="groups"');
    html = html.replace(/href="\/assets\//g, 'href="assets/');
    html = html.replace(/src="\/assets\//g, 'src="assets/');

    res.send(html);
  } else {
    res.status(404).send("KiÅŸi yÃ¶netim sayfasÄ± bulunamadÄ±.");
  }
});

// Grup yÃ¶netimi sayfasÄ±
app.get("/groups", (req, res) => {
  const groupsPath = path.join(process.cwd(), "groups.html");
  if (fs.existsSync(groupsPath)) {
    let html = fs.readFileSync(groupsPath, 'utf-8');

    // Inject base tag after <head>
    const baseTag = `<base href="${BASE_PATH ? BASE_PATH + '/' : '/'}">`;
    html = html.replace('<head>', `<head>\n    ${baseTag}`);

    // Inject BASE_PATH and fetch wrapper before first <script>
    const basePathScript = `<script>
      window.BASE_PATH = "${BASE_PATH || ''}";
      // Wrapper for fetch to handle BASE_PATH automatically
      window._fetch = window.fetch;
      window.fetch = function(url, ...args) {
        if (typeof url === 'string' && url.startsWith('/') && !url.startsWith('//')) {
          // Skip BASE_PATH only for /assets/ (CSS, JS) - .json files need BASE_PATH
          if (!url.startsWith('/assets/')) {
            url = window.BASE_PATH + url;
          }
        }
        return window._fetch(url, ...args);
      };
    </script>`;
    html = html.replace('<script', `${basePathScript}\n    <script`);

    // Fix absolute paths to relative
    html = html.replace(/href="\/"/g, 'href="./"');
    html = html.replace(/href="\/monitor"/g, 'href="monitor"');
    html = html.replace(/href="\/contacts"/g, 'href="contacts"');
    html = html.replace(/href="\/groups"/g, 'href="groups"');
    html = html.replace(/href="\/assets\//g, 'href="assets/');
    html = html.replace(/src="\/assets\//g, 'src="assets/');

    res.send(html);
  } else {
    res.status(404).send("Grup yÃ¶netim sayfasÄ± bulunamadÄ±.");
  }
});

// Sistem monitÃ¶r sayfasÄ±
app.get("/monitor", (req, res) => {
  const monitorPath = path.join(process.cwd(), "monitor.html");
  if (fs.existsSync(monitorPath)) {
    let html = fs.readFileSync(monitorPath, 'utf-8');

    // Inject base tag after <head>
    const baseTag = `<base href="${BASE_PATH ? BASE_PATH + '/' : '/'}">`;
    html = html.replace('<head>', `<head>\n    ${baseTag}`);

    // Inject BASE_PATH and fetch wrapper before first <script>
    const basePathScript = `<script>
      window.BASE_PATH = "${BASE_PATH || ''}";
      // Wrapper for fetch to handle BASE_PATH automatically
      window._fetch = window.fetch;
      window.fetch = function(url, ...args) {
        if (typeof url === 'string' && url.startsWith('/') && !url.startsWith('//')) {
          // Skip BASE_PATH only for /assets/ (CSS, JS) - .json files need BASE_PATH
          if (!url.startsWith('/assets/')) {
            url = window.BASE_PATH + url;
          }
        }
        return window._fetch(url, ...args);
      };
    </script>`;
    html = html.replace('<script', `${basePathScript}\n    <script`);

    // Fix absolute paths to relative
    html = html.replace(/href="\/"/g, 'href="./"');
    html = html.replace(/href="\/monitor"/g, 'href="monitor"');
    html = html.replace(/href="\/contacts"/g, 'href="contacts"');
    html = html.replace(/href="\/groups"/g, 'href="groups"');
    html = html.replace(/href="\/assets\//g, 'href="assets/');
    html = html.replace(/src="\/assets\//g, 'src="assets/');

    res.send(html);
  } else {
    res.status(404).send("MonitÃ¶r sayfasÄ± bulunamadÄ±.");
  }
});

// Monitor API - Ä°statistikler ve aktivite loglarÄ±
app.get("/api/monitor/stats", (req, res) => {
  try {
    res.json({
      ...global.monitorStats,
      activityLogs: global.activityLogs || []
    });
  } catch (error) {
    console.error("[API] Monitor stats hatasÄ±:", error);
    res.status(500).json({ error: "Ä°statistikler yÃ¼klenemedi" });
  }
});

// Monitor API - Cache bilgileri
app.get("/api/monitor/cache", (req, res) => {
  try {
    const cacheData = [];
    for (const [url, cache] of videoCache.entries()) {
      cacheData.push({
        url: url,
        fileName: path.basename(cache.filePath),
        size: cache.size,
        useCount: cache.useCount,
        downloadTime: cache.downloadTime
      });
    }
    res.json({ cacheData });
  } catch (error) {
    console.error("[API] Cache bilgileri hatasÄ±:", error);
    res.status(500).json({ error: "Cache bilgileri yÃ¼klenemedi" });
  }
});

// Monitor API - Sistem metrikleri
app.get("/api/monitor/system", (req, res) => {
  try {
    const memoryUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();

    res.json({
      memory: {
        used: Math.round(memoryUsage.heapUsed / 1024 / 1024), // MB
        total: Math.round(memoryUsage.heapTotal / 1024 / 1024), // MB
        percentage: Math.round((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100)
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system
      },
      uptime: Math.round(process.uptime()),
      pid: process.pid
    });
  } catch (error) {
    console.error("[API] Sistem metrikleri hatasÄ±:", error);
    res.status(500).json({ error: "Sistem metrikleri yÃ¼klenemedi" });
  }
});

// WhatsApp'tan gerÃ§ek kiÅŸileri Ã§ek - TUTARLI ve EKSIKSIZ
app.get("/api/whatsapp-contacts", async (req, res) => {
  if (!ready) {
    return res.status(503).json({ error: "WhatsApp hazÄ±r deÄŸil." });
  }

  try {
    console.log("[API] WhatsApp kiÅŸileri Ã§ekiliyor... (TutarlÄ± mod)");

    // Ã‡OKLU DENEME Ä°LE TUTARLI KÄ°ÅÄ° Ã‡EK
    let bestContacts = [];
    let bestCount = 0;
    const maxAttempts = 5;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        console.log(`[API] Deneme ${attempt}/${maxAttempts}...`);

        // WhatsApp'Ä±n kiÅŸileri tam yÃ¼klemesini bekle
        await new Promise(resolve => setTimeout(resolve, 2000));

        // WhatsApp'tan tÃ¼m kiÅŸileri Ã§ek
        const contacts = await client.getContacts();
        console.log(`[API] Deneme ${attempt}: ${contacts.length} toplam contact`);

        // DetaylÄ± filtreleme
        const filteredContacts = contacts.filter(contact => {
          const isMyContact = contact.isMyContact;
          const isGroup = contact.isGroup;
          const hasName = contact.name && contact.name.trim().length > 0;
          const hasValidPhone = contact.id && contact.id.user && contact.id.user.length >= 10;

          return isMyContact && !isGroup && hasName && hasValidPhone;
        });

        console.log(`[API] Deneme ${attempt}: ${filteredContacts.length} filtrelenmiÅŸ contact`);

        // En yÃ¼ksek sayÄ±yÄ± kaydet
        if (filteredContacts.length > bestCount) {
          bestCount = filteredContacts.length;
          bestContacts = filteredContacts;
          console.log(`[API] Yeni en yÃ¼ksek: ${bestCount} kiÅŸi (Deneme ${attempt})`);
        }

        // EÄŸer iki deneme arasÄ±nda fark yoksa, stable oldu demektir
        if (attempt > 1 && filteredContacts.length === bestCount) {
          console.log(`[API] Stable sonuÃ§ bulundu: ${bestCount} kiÅŸi`);
          break;
        }

      } catch (attemptError) {
        console.error(`[API] Deneme ${attempt} hatasÄ±:`, attemptError.message);
        // Sonraki denemeye geÃ§
      }
    }

    if (bestContacts.length === 0) {
      throw new Error("HiÃ§bir denemede kiÅŸi alÄ±namadÄ±");
    }

    console.log(`[API] En iyi sonuÃ§: ${bestContacts.length} kiÅŸi kullanÄ±lacak`);

    // Sadece geÃ§erli WhatsApp kullanÄ±cÄ±larÄ±nÄ± map et
    const whatsappContacts = bestContacts.map((contact, index) => {
      // Telefon numarasÄ±nÄ± temizle
      const phoneNumber = contact.id.user.replace(/[^\d]/g, '');

      // Yeni Ã¼lke tespit sistemi kullan
      const countryInfo = detectCountryFromPhone(phoneNumber);

      const contactData = {
        id: index + 1000, // WhatsApp kiÅŸileri iÃ§in yÃ¼ksek ID
        name: contact.name.trim(),
        phone: phoneNumber,
        country: countryInfo.country,
        language: countryInfo.language,
        active: true,
        tags: ["whatsapp"],
        addedDate: new Date().toISOString(),
        lastMessageDate: null,
        notes: `WhatsApp'tan aktarÄ±ldÄ± - ${contact.isBusiness ? 'Ä°ÅŸ hesabÄ±' : 'KiÅŸisel'}`
      };

      return contactData;
    });

    // Tekrar eden telefon numaralarÄ±nÄ± kaldÄ±r
    const uniqueContacts = [];
    const seenPhones = new Set();

    for (const contact of whatsappContacts) {
      if (!seenPhones.has(contact.phone)) {
        seenPhones.add(contact.phone);
        uniqueContacts.push(contact);
      }
    }

    console.log(`[API] FINAL: ${uniqueContacts.length} benzersiz WhatsApp kiÅŸisi bulundu.`);

    res.json({
      success: true,
      count: uniqueContacts.length,
      contacts: uniqueContacts,
      stats: {
        attempts: maxAttempts,
        bestAttemptCount: bestCount,
        total: bestContacts.length,
        filtered: bestContacts.length,
        unique: uniqueContacts.length,
        duplicatesRemoved: whatsappContacts.length - uniqueContacts.length
      }
    });

  } catch (error) {
    console.error("[API] WhatsApp kiÅŸileri Ã§ekilemedi:", error.message);
    res.status(500).json({
      error: "WhatsApp kiÅŸileri Ã§ekilemedi.",
      details: error.message
    });
  }
});

// WhatsApp kiÅŸilerini contacts.json'a ekle/birleÅŸtir
app.post("/api/import-whatsapp-contacts", async (req, res) => {
  if (!ready) {
    return res.status(503).json({ error: "WhatsApp hazÄ±r deÄŸil." });
  }

  try {
    console.log("[IMPORT] WhatsApp kiÅŸileri import ediliyor...");

    // WhatsApp kiÅŸilerini Ã§ek
    const whatsappResponse = await fetch(`http://localhost:${PORT}/api/whatsapp-contacts`);
    const whatsappData = await whatsappResponse.json();

    if (!whatsappData.success) {
      throw new Error("WhatsApp kiÅŸileri Ã§ekilemedi.");
    }

    console.log(`[IMPORT] WhatsApp'tan ${whatsappData.count} kiÅŸi alÄ±ndÄ±`);
    console.log(`[IMPORT] Stats:`, whatsappData.stats);

    // Mevcut contacts.json'Ä± yÃ¼kle
    const contactsData = loadContacts();
    console.log(`[IMPORT] Mevcut contacts.json'da ${contactsData.contacts.length} kiÅŸi var`);

    // Mevcut kiÅŸiler ile WhatsApp kiÅŸilerini birleÅŸtir (telefon bazÄ±nda kontrol)
    const existingPhones = new Set(contactsData.contacts.map(c => c.phone));
    console.log(`[IMPORT] Mevcut telefon numaralarÄ±: ${existingPhones.size}`);

    const newContacts = whatsappData.contacts.filter(c => {
      const isNew = !existingPhones.has(c.phone);
      return isNew;
    });

    console.log(`[IMPORT] ${newContacts.length} yeni kiÅŸi ekleniyor`);

    // Yeni kiÅŸileri ekle
    contactsData.contacts = [...contactsData.contacts, ...newContacts];

    // Son import tarihini kaydet
    contactsData.lastWhatsAppImport = new Date().toISOString();
    contactsData.importStats = {
      lastImportDate: new Date().toISOString(),
      whatsappTotal: whatsappData.stats.total,
      whatsappFiltered: whatsappData.stats.filtered,
      whatsappUnique: whatsappData.stats.unique,
      previousContactCount: contactsData.contacts.length - newContacts.length,
      newContactsAdded: newContacts.length,
      totalAfterImport: contactsData.contacts.length
    };

    // Kaydet
    if (saveContacts(contactsData)) {
      console.log(`[IMPORT] BaÅŸarÄ±lÄ±: ${newContacts.length} yeni kiÅŸi eklendi, toplam: ${contactsData.contacts.length}`);

      res.json({
        success: true,
        imported: newContacts.length,
        total: contactsData.contacts.length,
        stats: contactsData.importStats,
        message: `${newContacts.length} yeni WhatsApp kiÅŸisi eklendi. Toplam: ${contactsData.contacts.length}`
      });
    } else {
      throw new Error("Kaydetme hatasÄ±.");
    }

  } catch (error) {
    console.error("[IMPORT] WhatsApp kiÅŸileri import edilemedi:", error.message);
    res.status(500).json({
      error: "WhatsApp kiÅŸileri import edilemedi.",
      details: error.message
    });
  }
});

// ========================================
// WHATSAPP GROUPS ENDPOINTS
// ========================================

// WhatsApp'tan grup listesini Ã§ek
app.get("/api/whatsapp-groups", async (req, res) => {
  if (!ready) {
    return res.status(503).json({ error: "WhatsApp hazÄ±r deÄŸil." });
  }

  try {
    console.log("[API] WhatsApp gruplarÄ± Ã§ekiliyor...");

    // WhatsApp'tan tÃ¼m chatler'Ä± Ã§ek
    const chats = await client.getChats();
    console.log(`[API] ${chats.length} toplam chat bulundu`);

    // Sadece gruplarÄ± filtrele
    const groups = chats.filter(chat => chat.isGroup);
    console.log(`[API] ${groups.length} grup bulundu`);

    // Grup detaylarÄ±nÄ± map et
    const groupDetails = await Promise.all(groups.map(async (group, index) => {
      try {
        // Grup metadata'sÄ±nÄ± Ã§ek (participants iÃ§in)
        const participantCount = group.participants ? group.participants.length : 0;

        return {
          id: group.id._serialized, // Ã–rnek: "1234567890-123456789@g.us"
          name: group.name || "Ä°simsiz Grup",
          participantCount: participantCount,
          isActive: true, // VarsayÄ±lan olarak aktif
          isGroup: true,
          createdAt: group.createdAt || new Date().getTime(),
          addedDate: new Date().toISOString()
        };
      } catch (error) {
        console.error(`[API] Grup ${group.name} iÃ§in hata:`, error.message);
        return null;
      }
    }));

    // Null olan (hata alan) gruplarÄ± filtrele
    const validGroups = groupDetails.filter(g => g !== null);

    console.log(`[API] ${validGroups.length} grup baÅŸarÄ±yla iÅŸlendi`);

    res.json({
      success: true,
      groups: validGroups,
      count: validGroups.length,
      stats: {
        total: chats.length,
        groups: groups.length,
        validGroups: validGroups.length
      }
    });

  } catch (error) {
    console.error("[API] WhatsApp gruplarÄ± Ã§ekilemedi:", error.message);
    res.status(500).json({
      error: "WhatsApp gruplarÄ± Ã§ekilemedi.",
      details: error.message
    });
  }
});

// WhatsApp gruplarÄ±nÄ± import et ve groups.json'a kaydet
app.post("/api/import-whatsapp-groups", async (req, res) => {
  if (!ready) {
    return res.status(503).json({ error: "WhatsApp hazÄ±r deÄŸil." });
  }

  try {
    console.log("[IMPORT-GROUPS] WhatsApp gruplarÄ± import ediliyor...");

    // WhatsApp gruplarÄ±nÄ± Ã§ek
    const whatsappResponse = await fetch(`http://localhost:${PORT}/api/whatsapp-groups`);
    const whatsappData = await whatsappResponse.json();

    if (!whatsappData.success) {
      throw new Error("WhatsApp gruplarÄ± Ã§ekilemedi.");
    }

    console.log(`[IMPORT-GROUPS] WhatsApp'tan ${whatsappData.count} grup alÄ±ndÄ±`);

    // Mevcut groups.json'Ä± yÃ¼kle
    const groupsData = loadGroups();
    console.log(`[IMPORT-GROUPS] Mevcut groups.json'da ${groupsData.groups.length} grup var`);

    // Mevcut gruplar ile WhatsApp gruplarÄ±nÄ± birleÅŸtir (id bazÄ±nda kontrol)
    const existingGroupIds = new Set(groupsData.groups.map(g => g.id));
    console.log(`[IMPORT-GROUPS] Mevcut grup ID'leri: ${existingGroupIds.size}`);

    const newGroups = whatsappData.groups.filter(g => {
      const isNew = !existingGroupIds.has(g.id);
      return isNew;
    });

    console.log(`[IMPORT-GROUPS] ${newGroups.length} yeni grup ekleniyor`);

    // Yeni gruplarÄ± ekle
    groupsData.groups = [...groupsData.groups, ...newGroups];

    // Son import tarihini kaydet
    groupsData.lastWhatsAppImport = new Date().toISOString();
    groupsData.importStats = {
      lastImportDate: new Date().toISOString(),
      whatsappTotal: whatsappData.stats.total,
      whatsappGroups: whatsappData.stats.groups,
      whatsappValidGroups: whatsappData.stats.validGroups,
      previousGroupCount: groupsData.groups.length - newGroups.length,
      newGroupsAdded: newGroups.length,
      totalAfterImport: groupsData.groups.length
    };

    // Kaydet
    if (saveGroups(groupsData)) {
      console.log(`[IMPORT-GROUPS] BaÅŸarÄ±lÄ±: ${newGroups.length} yeni grup eklendi, toplam: ${groupsData.groups.length}`);

      res.json({
        success: true,
        imported: newGroups.length,
        total: groupsData.groups.length,
        stats: groupsData.importStats,
        message: `${newGroups.length} yeni WhatsApp grubu eklendi. Toplam: ${groupsData.groups.length}`
      });
    } else {
      throw new Error("Kaydetme hatasÄ±.");
    }

  } catch (error) {
    console.error("[IMPORT-GROUPS] WhatsApp gruplarÄ± import edilemedi:", error.message);
    res.status(500).json({
      error: "WhatsApp gruplarÄ± import edilemedi.",
      details: error.message
    });
  }
});

// WhatsApp'a kiÅŸi ekle
app.post("/api/add-to-whatsapp", async (req, res) => {
  if (!ready) {
    return res.status(503).json({ error: "WhatsApp hazÄ±r deÄŸil." });
  }

  try {
    const { name, phone, message } = req.body;

    if (!name || !phone || !message) {
      return res.status(400).json({ error: "Ad, telefon numarasÄ± ve mesaj gerekli." });
    }

    console.log(`[WHATSAPP ADD] KiÅŸi ekleniyor: ${name} - ${phone}`);

    // Telefon numarasÄ±nÄ± dÃ¼zelt (baÅŸÄ±nda + yoksa ekle)
    let formattedPhone = phone.replace(/\D/g, ''); // Sadece rakamlar
    if (!formattedPhone.startsWith('90')) {
      formattedPhone = '90' + formattedPhone;
    }
    formattedPhone = '+' + formattedPhone;

    // WhatsApp'a kiÅŸi olarak eklemek iÃ§in WhatsApp Web API'si kullan
    // Not: WhatsApp Web.js ile direkt kiÅŸi eklemek mÃ¼mkÃ¼n deÄŸil
    // Alternatif olarak kiÅŸiye mesaj gÃ¶ndererek kiÅŸi listesine eklenebilir

    const chatId = formattedPhone + '@c.us';

    // Ã–zel karÅŸÄ±lama mesajÄ±nÄ± gÃ¶nder
    await client.sendMessage(chatId, message);

    console.log(`[WHATSAPP ADD] BaÅŸarÄ±lÄ±: ${name} (${formattedPhone}) WhatsApp'a eklendi`);

    res.json({
      success: true,
      message: `${name} WhatsApp kiÅŸilerinize eklendi`,
      phone: formattedPhone,
      sentMessage: message
    });

  } catch (error) {
    console.error("[WHATSAPP ADD] KiÅŸi eklenirken hata:", error.message);
    res.status(500).json({
      error: "KiÅŸi WhatsApp'a eklenemedi.",
      details: error.message
    });
  }
});

app.get("/qr", async (req, res) => {
  try {
    if (!lastQrString) return res.json({ dataUrl: "" });
    const dataUrl = await QRCode.toDataURL(lastQrString, { margin: 1, scale: 6 });
    return res.json({ dataUrl });
  } catch {
    return res.json({ dataUrl: "" });
  }
});

app.get("/status", (req, res) => res.json({ ready, port: PORT, tunnelUrl: TUNNEL_URL }));

// Health check endpoint (Render.com iÃ§in)
app.get("/health", (req, res) => {
  res.json({
    status: 'ok',
    whatsapp: ready ? 'connected' : 'disconnected',
    uptime: Math.floor(process.uptime()),
    queue: QUEUE.length,
    timestamp: new Date().toISOString()
  });
});

// Tunnel URL'yi dÃ¶ner
app.get("/api/tunnel/url", (req, res) => {
  if (TUNNEL_URL) return res.json({ url: TUNNEL_URL });
  return res.status(404).json({ error: "Tunnel not active" });
});

// Default browser'da arayÃ¼zÃ¼ aÃ§ (tunnel varsa onu, yoksa localhost)
app.get("/open", (req, res) => {
  const target = TUNNEL_URL || `http://localhost:${PORT}`;
  openInDefaultBrowser(target);
  res.json({ opened: true, url: target });
});

// Sistem monitÃ¶r API'leri
// Global: Son iÅŸlenen gallery batchId'yi takip et
let lastGalleryBatchId = null;

app.post("/api/send-video-file", (req, res, next) => {
  // REQUEST DEBUG
  console.log('[RAW REQUEST] Headers:', JSON.stringify(req.headers, null, 2));
  console.log('[RAW REQUEST] Content-Type:', req.get('content-type'));
  console.log('[RAW REQUEST] Content-Length:', req.get('content-length'));
  console.log('[RAW REQUEST] Method:', req.method);

  // Multer error handler (gallery storage)
  galleryUpload.single('video')(req, res, (err) => {
    if (err) {
      console.error('[MULTER ERROR]', err.message);
      console.error('[MULTER ERROR] Code:', err.code);
      console.error('[MULTER ERROR] Field:', err.field);
      console.error('[MULTER ERROR] Stack:', err.stack);
      logger.error('[MULTER ERROR]', { message: err.message, code: err.code, field: err.field });
      return res.status(400).json({
        error: 'Video upload hatasÄ±: ' + err.message,
        code: err.code
      });
    }
    console.log('[MULTER SUCCESS] File parsed successfully');
    next();
  });
}, async (req, res) => {
  try {
    console.log('[GALLERY UPLOAD] Request alÄ±ndÄ±');
    console.log('[GALLERY UPLOAD] req.file:', req.file);
    console.log('[GALLERY UPLOAD] req.body:', req.body);

    if (!ready) {
      logger.error('[GALLERY UPLOAD] WhatsApp hazÄ±r deÄŸil');
      return res.status(503).json({ error: "WhatsApp hazÄ±r deÄŸil. QR'Ä± tarayÄ±n." });
    }

    const {
      caption,
      batchSize = 5,
      batchId = 'gallery',
      isLastVideoInBatch = false,
      autoFanout = true // â† 5. videodan sonra kalan hedeflere (grup+kiÅŸiler) otomatik daÄŸÄ±t
    } = req.body;
    const videoFile = req.file;

    // YENÄ° BATCH baÅŸladÄ±ysa (batchId deÄŸiÅŸti), eski dosyalarÄ± temizle
    if (lastGalleryBatchId !== batchId) {
      console.log(`[GALLERY CLEANUP] Yeni batch (${batchId}), eski batch (${lastGalleryBatchId})`);
      console.log('[GALLERY CLEANUP] tmp_videos klasÃ¶rÃ¼ temizleniyor...');
      try {
        const files = fs.readdirSync(GALLERY_TMP);
        let deletedCount = 0;
        files.forEach(file => {
          const filePath = path.join(GALLERY_TMP, file);
          if (fs.statSync(filePath).isFile()) {
            fs.unlinkSync(filePath);
            deletedCount++;
          }
        });
        console.log(`[GALLERY CLEANUP] ${deletedCount} eski dosya silindi`);
      } catch (err) {
        console.error('[GALLERY CLEANUP] Hata:', err.message);
      }
      lastGalleryBatchId = batchId;
    }

    if (!videoFile) {
      logger.error('[GALLERY UPLOAD] Video dosyasÄ± bulunamadÄ±');
      return res.status(400).json({ error: "Video dosyasÄ± gerekli." });
    }

    logger.info(`[GALLERY UPLOAD] Video: ${videoFile.originalname} (${videoFile.size} bytes)`);

    // Dosya zaten gallery tmp klasÃ¶rÃ¼nde saklanmÄ±ÅŸ durumda (GALLERY_TMP)
    const finalFilePath = videoFile.path;
    const finalFileName = path.basename(finalFilePath);
    console.log(`[GALLERY UPLOAD] Video kaydedildi: ${finalFilePath}`);

    // CACHE SÄ°STEMÄ°NE EKLE
    addFileToCache(videoFile.originalname, finalFilePath, videoFile.size);
    console.log(`[GALLERY CACHE] ${videoFile.originalname} cache'e eklendi`);

    //
    // 1. AKTÄ°F HEDEF LÄ°STESÄ° (Ã–NCE GRUPLAR, SONRA KÄ°ÅÄ°LER)
    //
    const groupsData = loadGroups();
    const activeGroups = (groupsData.groups || []).filter(g => g.isActive); // "Test grup" aktif true :contentReference[oaicite:4]{index=4}

    const contactsData = loadContacts();
    const activeContacts = (contactsData.contacts || []).filter(c => c.active); // "Arif Bey" active true :contentReference[oaicite:5]{index=5}

    const unifiedTargets = [
      ...activeGroups.map(g => ({
        type: 'group',
        id: g.id,
        name: g.name || "Group",
        country: null
      })),
      ...activeContacts.map(c => ({
        type: 'contact',
        phone: c.phone,
        name: c.name || "Contact",
        country: c.country || null
      }))
    ];

    if (unifiedTargets.length === 0) {
      try { fs.unlinkSync(finalFilePath); } catch { }
      return res.status(400).json({ error: "Aktif hedef bulunamadÄ± (ne aktif grup ne aktif kiÅŸi var)." });
    }

    //
    // 2. BATCH HEDEFÄ°NÄ° SEÃ‡
    //
    const totalTargets = unifiedTargets.length;
    const batchInfo = getContactsForBatch(
      batchId,
      Number(batchSize) || 5,
      totalTargets
    );

    const target = unifiedTargets[batchInfo.contactIndex];
    const currentVideoIndex = batchInfo.videoInCurrentBatch; // 1..batchSize
    const autoIsLastVideo = currentVideoIndex >= Number(batchSize);
    const finalIsLastVideo = isLastVideoInBatch || autoIsLastVideo;

    console.log(
      `[GALLERY BATCH] Video ${currentVideoIndex}/${batchSize} â†’ ${target.name} (${target.type === 'group' ? target.id : target.phone}) ${finalIsLastVideo ? '(SON VIDEO)' : ''}`
    );

    //
    // 3. BU BATCH Ä°Ã‡Ä°N GALERÄ° SETÄ°NÄ° HATIRLA
    //
    const reg0 = batchFiles.get(batchId) || { files: [], size: Number(batchSize) || 5, fanoutDone: false };
    const idx = currentVideoIndex - 1; // 0..batchSize-1
    reg0.files[idx] = { path: finalFilePath, caption: caption || "" };
    reg0.size = Number(batchSize) || reg0.size;
    batchFiles.set(batchId, reg0);

    //
    // 4. KUYRUÄA EKLE
    //
    let jobData;
    if (target.type === 'group') {
      jobData = {
        to: target.id,
        caption: caption || "",
        videoFilePath: finalFilePath,
        isFileUpload: true,
        batchId: batchId,
        isBatchOperation: true,
        contactName: target.name,
        videoInSet: currentVideoIndex,
        totalInSet: Number(batchSize) || 5,
        type: 'group'
      };
    } else {
      jobData = {
        to: target.phone,
        caption: caption || "",
        videoFilePath: finalFilePath,
        isFileUpload: true,
        batchId: batchId,
        isBatchOperation: true,
        contactName: target.name,
        videoInSet: currentVideoIndex,
        totalInSet: Number(batchSize) || 5,
        type: 'contact'
      };
    }
    enqueue(jobData);

    //
    // 5. SON VÄ°DEOYSA FANOUT ve ROTASYON
    //
    if (finalIsLastVideo) {
      const stateBeforeAdvance = batchState.get(batchId); // henÃ¼z ilerletmedik
      const regNow = batchFiles.get(batchId);
      const files = (regNow?.files || []).filter(Boolean);

      if (autoFanout && !regNow?.fanoutDone && files.length === (Number(batchSize) || 5)) {
        const startIdx = stateBeforeAdvance?.currentContactIndex || 0;

        // ilk hedef zaten aldÄ± â†’ offset 1'den baÅŸla
        for (let offset = 1; offset < totalTargets; offset++) {
          const ci = (startIdx + offset) % totalTargets;
          const dest = unifiedTargets[ci];

          // gÃ¼venlik
          if (dest.type === 'contact') {
            if (!dest.phone || dest.phone.length < 5) continue;
          } else {
            if (!dest.id) continue;
          }

          files.forEach((fileData, i) => {
            if (dest.type === 'group') {
              enqueue({
                to: dest.id,
                caption: fileData.caption || "",
                videoFilePath: fileData.path,
                isFileUpload: true,
                batchId,
                isBatchOperation: true,
                contactName: dest.name,
                videoInSet: i + 1,
                totalInSet: Number(batchSize) || 5,
                type: 'group'
              });
            } else {
              enqueue({
                to: dest.phone,
                caption: fileData.caption || "",
                videoFilePath: fileData.path,
                isFileUpload: true,
                batchId,
                isBatchOperation: true,
                contactName: dest.name,
                videoInSet: i + 1,
                totalInSet: Number(batchSize) || 5,
                type: 'contact'
              });
            }
          });
        }

        regNow.fanoutDone = true;
        batchFiles.set(batchId, regNow);

        console.log(
          `[BATCH FANOUT] '${batchId}' (gallery) iÃ§in ${totalTargets} hedefe otomatik enqueue tamamlandÄ±.`
        );
      }

      // en SONA aldÄ±k
      markBatchComplete(batchId, totalTargets);

      console.log(
        `[GALLERY BATCH COMPLETE] ${batchSize} video ${target.name}'e gÃ¶nderildi, sÄ±radaki hedefe geÃ§iliyor`
      );
    }

    console.log(
      `[GALLERY QUEUED] Video kuyruÄŸa eklendi: ${finalFileName} â†’ ${target.name}`
    );

    return res.json({
      success: true,
      queued: true,
      fileName: videoFile.originalname,
      targetContact: {
        name: target.name,
        phone: target.type === 'contact' ? target.phone : null,
        groupId: target.type === 'group' ? target.id : null,
        contactIndex: batchInfo.contactIndex + 1,
        type: target.type
      },
      batchInfo: {
        batchId,
        batchSize: Number(batchSize) || 5,
        videoIndex: currentVideoIndex,
        isLastVideo: finalIsLastVideo,
        nextContactReady: finalIsLastVideo
      },
      totalTargets,
      message: `Video ${currentVideoIndex}/${batchSize} â†’ ${target.name}`
    });

  } catch (error) {
    logger.error(`[ERROR] Gallery video upload hatasÄ±:`, {
      message: error.message,
      stack: error.stack,
      file: req.file,
      body: req.body
    });
    console.error(`[ERROR] Gallery video upload hatasÄ±:`, error.message);
    console.error(`[ERROR] Stack:`, error.stack);
    try {
      if (req.file && req.file.path && fs.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
      }
    } catch { }
    return res.status(500).json({ error: "Video upload hatasÄ±: " + error.message });
  }
});



// N8N â†’ Tek alÄ±cÄ±: { "to":"9053...", "videoUrl":"https://...", "caption":"..." }
app.post("/send-video", (req, res) => {
  const startTime = Date.now();
  const { to, videoUrl, caption } = req.body || {};
  logEndpoint('/send-video', 'POST', req.body, 'started');

  if (!to || !videoUrl) {
    const error = { error: "to ve videoUrl zorunludur." };
    logger.warn('[SEND-VIDEO] Validation failed', { to, videoUrl, error: error.error });
    logEndpoint('/send-video', 'POST', req.body, { ...error, success: false });
    return res.status(400).json(error);
  }

  if (!ready) {
    const error = { error: "WhatsApp hazÄ±r deÄŸil. QR'Ä± tarayÄ±n." };
    logger.warn('[SEND-VIDEO] WhatsApp not ready', { to, videoUrl });
    logEndpoint('/send-video', 'POST', req.body, { ...error, success: false, ready });
    return res.status(503).json(error);
  }

  enqueue({ to, caption, videoUrl });
  const processingTime = Date.now() - startTime;
  const response = { queued: true, queueLength: QUEUE.length, processingTime };
  logger.info('[SEND-VIDEO] Success', { to, videoUrl, queueLength: QUEUE.length, processingTime });
  logEndpoint('/send-video', 'POST', req.body, { ...response, success: true });
  res.json(response);
});

// N8N â†’ Ã‡oklu: { "items":[ {to, videoUrl, caption}, ... ] }
app.post("/send-video-batch", (req, res) => {
  const startTime = Date.now();
  const items = (req.body && Array.isArray(req.body.items)) ? req.body.items : [];
  logEndpoint('/send-video-batch', 'POST', req.body, 'started');

  if (!items.length) {
    const error = { error: "items boÅŸ." };
    logger.warn('[SEND-VIDEO-BATCH] Validation failed', { itemsCount: items.length, error: error.error });
    logEndpoint('/send-video-batch', 'POST', req.body, { ...error, success: false });
    return res.status(400).json(error);
  }

  if (!ready) {
    const error = { error: "WhatsApp hazÄ±r deÄŸil. QR'Ä± tarayÄ±n." };
    logger.warn('[SEND-VIDEO-BATCH] WhatsApp not ready', { itemsCount: items.length });
    logEndpoint('/send-video-batch', 'POST', req.body, { ...error, success: false, ready });
    return res.status(503).json(error);
  }

  for (const it of items) {
    if (it.to && it.videoUrl) {
      enqueue({ to: it.to, caption: it.caption || "", videoUrl: it.videoUrl });
    }
  }

  const processingTime = Date.now() - startTime;
  const response = { queued: items.length, queueLength: QUEUE.length, processingTime };
  logger.info('[SEND-VIDEO-BATCH] Success', { itemsCount: items.length, queueLength: QUEUE.length, processingTime });
  logEndpoint('/send-video-batch', 'POST', req.body, { ...response, success: true });
  res.json(response);
});

// N8N â†’ KiÅŸi listesi bazlÄ± toplu gÃ¶nderim (ESKÄ° - Her video tÃ¼m kiÅŸilere)
app.post("/send-video-to-contacts", (req, res) => {
  const startTime = Date.now();
  const { videoUrl, caption, country, language } = req.body || {};
  logEndpoint('/send-video-to-contacts', 'POST', req.body, 'started');

  if (!videoUrl) {
    const error = { error: "videoUrl gerekli." };
    logger.warn('[SEND-VIDEO-TO-CONTACTS] Validation failed', { videoUrl, error: error.error });
    logEndpoint('/send-video-to-contacts', 'POST', req.body, { ...error, success: false });
    return res.status(400).json(error);
  }

  if (!ready) {
    const error = { error: "WhatsApp hazÄ±r deÄŸil. QR'Ä± tarayÄ±n." };
    logger.warn('[SEND-VIDEO-TO-CONTACTS] WhatsApp not ready', { videoUrl, country, language });
    logEndpoint('/send-video-to-contacts', 'POST', req.body, { ...error, success: false, ready });
    return res.status(503).json(error);
  }

  const contactsData = loadContacts();

  /*
    function loadGroups() {
      try {
        const file = path.join(__dirname, "groups.json");
        if (fs.existsSync(file)) {
          const data = JSON.parse(fs.readFileSync(file, "utf8"));
          return data;
        } else {
          console.warn("[WARN] groups.json bulunamadÄ±, boÅŸ liste dÃ¶ndÃ¼rÃ¼lÃ¼yor.");
          return { groups: [] };
        }
      } catch (err) {
        console.error("[ERROR] groups.json okunamadÄ±:", err);
        return { groups: [] };
      }
    }
  */

  let activeContacts = contactsData.contacts.filter(c => c.active);

  // Ãœlke filtresi
  if (country) {
    activeContacts = activeContacts.filter(c => c.country === country.toUpperCase());
  }

  // Dil filtresi
  if (language) {
    activeContacts = activeContacts.filter(c => c.language === language.toLowerCase());
  }

  // KuyruÄŸa ekle
  let queued = 0;
  for (const contact of activeContacts) {
    if (contact.phone && contact.phone.length > 5) {
      enqueue({
        to: contact.phone,
        caption: caption || "",
        videoUrl: videoUrl
      });
      queued++;
    }
  }

  const processingTime = Date.now() - startTime;
  const response = {
    queued: queued,
    totalContacts: activeContacts.length,
    filters: { country, language },
    queueLength: QUEUE.length,
    processingTime
  };

  logger.info('[SEND-VIDEO-TO-CONTACTS] Success', { queued, totalContacts: activeContacts.length, country, language, queueLength: QUEUE.length, processingTime });
  logEndpoint('/send-video-to-contacts', 'POST', req.body, { ...response, success: true });
  res.json(response);
});

// N8N â†’ YENÄ°: Batch sistemi - N video aynÄ± hedefe (grup veya kiÅŸi), sonra diÄŸer hedefe (fanout ile)

app.post("/send-video-to-contacts-grouped", async (req, res) => {
  const startTime = Date.now();
  logEndpoint('/send-video-to-contacts-grouped', 'POST', req.body, 'started');

  // Forward parametreleri (spam korumasÄ±)
  const FORWARD_DELAY = 600;            // 0.6s
  const FORWARD_BURST_SIZE = 50;        // 50 kiÅŸi
  const FORWARD_BURST_COOLDOWN = 60000; // 60s

  const {
    videoUrls,        // YENÄ°: array mode
    captions,         // YENÄ°: array mode
    country,
    language,
  } = req.body || {};

  logger.info('[GROUPED-FORWARD] Request received', {
    videoCount: videoUrls?.length,
    country,
    language,
    ready
  });

  if (!videoUrls || !Array.isArray(videoUrls) || videoUrls.length === 0) {
    logger.error('[GROUPED-FORWARD] Missing videoUrls array');
    logEndpoint('/send-video-to-contacts-grouped', 'POST', req.body, { error: 'videoUrls array gerekli' });
    return res.status(400).json({ error: "videoUrls array gerekli." });
  }

  if (!ready) {
    logger.error('[GROUPED-FORWARD] WhatsApp not ready');
    logEndpoint('/send-video-to-contacts-grouped', 'POST', req.body, { error: 'WhatsApp hazÄ±r deÄŸil' });
    return res.status(503).json({ error: "WhatsApp hazÄ±r deÄŸil. QR'Ä± tarayÄ±n." });
  }

  try {
    // 1) AKTÄ°F HEDEF LÄ°STESÄ° (Unified targets: grup + kiÅŸi)
    const groupsData = loadGroups();
    let activeGroups = (groupsData.groups || []).filter(g => g.isActive);

    const contactsData = loadContacts();
    let filteredContacts = (contactsData.contacts || []).filter(c => c.active);

    // Ãœlke / dil filtresi SADECE kiÅŸilere uygula
    if (country) {
      filteredContacts = filteredContacts.filter(c => c.country === country.toUpperCase());
    }
    if (language) {
      filteredContacts = filteredContacts.filter(c => c.language === language.toLowerCase());
    }

    // unifiedTargets: Ã¶nce aktif gruplar, sonra filtrelenmiÅŸ aktif kiÅŸiler
    const unifiedTargets = [
      ...activeGroups.map(g => ({
        type: 'group',
        id: g.id,
        name: g.name || "Group"
      })),
      ...filteredContacts.map(c => ({
        type: 'contact',
        phone: c.phone,
        name: c.name || "Contact"
      }))
    ];

    if (unifiedTargets.length === 0) {
      return res.json({
        queued: 0,
        totalTargets: 0,
        message: "Aktif hedef bulunamadÄ± (ne aktif grup ne uygun kiÅŸi var)."
      });
    }

    console.log(`[GROUPED-FORWARD] ${unifiedTargets.length} hedef bulundu, ${videoUrls.length} video gÃ¶nderilecek`);

    // 2) Ä°LK HEDEFE TÃœM VÄ°DEOLARI GÃ–NDER (cache + msg IDs sakla)
    let messageIds = [];
    const firstTarget = unifiedTargets[0];
    const firstTo = firstTarget.type === 'group' ? firstTarget.id : firstTarget.phone;

    console.log(`[GROUPED-FORWARD] Ä°lk hedef: ${firstTarget.name} (${firstTarget.type})`);

    for (let i = 0; i < videoUrls.length; i++) {
      const vUrl = videoUrls[i];
      const cap = (captions && captions[i]) ? captions[i] : '';

      console.log(`[GROUPED-FORWARD] Video ${i + 1}/${videoUrls.length} cache'leniyor...`);
      const cachedPath = await getOrCacheVideo(vUrl);
      const media = MessageMedia.fromFilePath(cachedPath);

      let sentMsg;
      if (firstTarget.type === 'group') {
        const chat = await client.getChatById(firstTo);
        if (!chat.isGroup) throw new Error(`${firstTo} bir grup deÄŸil!`);

        // Admin kontrolÃ¼
        if (chat.groupMetadata && chat.groupMetadata.announce) {
          const myId = client.info.wid._serialized;
          const isAdmin = chat.groupMetadata.participants.some(
            p => p.id._serialized === myId && (p.isAdmin || p.isSuperAdmin)
          );
          if (!isAdmin) throw new Error(`Grupta admin deÄŸilsiniz: ${firstTarget.name}`);
        }

        sentMsg = await chat.sendMessage(media, { caption: cap });
      } else {
        const jid = `${firstTo}@c.us`;
        sentMsg = await client.sendMessage(jid, media, { caption: cap });
      }

      messageIds.push(sentMsg.id._serialized);
      console.log(`[GROUPED-FORWARD] Video ${i + 1}/${videoUrls.length} gÃ¶nderildi â†’ ${firstTarget.name}`);

      // Ä°statistik
      global.monitorStats.totalProcessed++;
      global.monitorStats.todayCount++;

      // Anti-spam delay (send iÃ§in 2s)
      await new Promise(r => setTimeout(r, 2000));
    }

    addActivityLog('success', `Ä°lk send tamamlandÄ±: ${firstTarget.name} (${videoUrls.length} video)`);

    // 3) DÄ°ÄER HEDEFLERE FORWARD ET (burst control ile)
    let forwardedCount = 0;
    for (let i = 1; i < unifiedTargets.length; i++) {
      const target = unifiedTargets[i];
      const targetTo = target.type === 'group' ? target.id : target.phone;

      if (target.type === 'group' && !target.id) continue;
      if (target.type === 'contact' && (!target.phone || target.phone.length < 5)) continue;

      console.log(`[GROUPED-FORWARD] Forward ${i}/${unifiedTargets.length - 1}: ${target.name} (${targetTo})`);

      try {
        const forwardResult = await client.forwardMessages(targetTo, messageIds, { silent: true });

        if (forwardResult.length !== messageIds.length) {
          logger.warn('[GROUPED-FORWARD] Partial forward', {
            targetTo,
            expected: messageIds.length,
            actual: forwardResult.length
          });
        }

        forwardedCount++;
        addActivityLog('success', `Forward tamam: ${target.name} (${messageIds.length} mesaj)`);

        // Ä°statistik
        global.monitorStats.totalProcessed += messageIds.length;
        global.monitorStats.todayCount += messageIds.length;

        // Burst control: Her forward sonrasÄ± delay
        await new Promise(r => setTimeout(r, FORWARD_DELAY));

        // Burst control: 50 kiÅŸiye ulaÅŸÄ±nca 60s bekle
        if (forwardedCount % FORWARD_BURST_SIZE === 0) {
          console.log(`[GROUPED-FORWARD] ${forwardedCount} forward tamamlandÄ±, ${FORWARD_BURST_COOLDOWN / 1000}s cooldown...`);
          addActivityLog('info', `${forwardedCount} kiÅŸiye gÃ¶nderildi, ${FORWARD_BURST_COOLDOWN / 1000}s bekleniyor...`);
          await new Promise(r => setTimeout(r, FORWARD_BURST_COOLDOWN));
        }

      } catch (forwardError) {
        logger.error('[GROUPED-FORWARD] Forward failed', {
          error: forwardError.message,
          target: target.name,
          targetTo
        });
        addActivityLog('error', `Forward hatasÄ±: ${target.name} - ${forwardError.message}`);
        // Devam et, tÃ¼m hedefleri atlamayalÄ±m
      }
    }

    // 4) Cache temizle
    clearAllCache();
    console.log(`[GROUPED-FORWARD] TÃ¼m iÅŸlemler tamamlandÄ±: ${videoUrls.length} video â†’ ${unifiedTargets.length} hedef (1 send + ${forwardedCount} forward)`);

    const processingTime = Date.now() - startTime;
    const responseData = {
      success: true,
      mode: 'forward',
      sentToFirst: firstTarget.name,
      totalVideos: videoUrls.length,
      totalTargets: unifiedTargets.length,
      forwardedTo: forwardedCount,
      queueLength: QUEUE.length,
      processingTime,
      estimatedTime: `~${Math.ceil((forwardedCount * FORWARD_DELAY) / 1000 / 60)} dakika`
    };

    logger.info('[GROUPED-FORWARD] Success', responseData);
    logEndpoint('/send-video-to-contacts-grouped', 'POST', req.body, responseData);
    return res.json(responseData);

  } catch (error) {
    logger.error("[GROUPED-FORWARD] Error", {
      error: error.message,
      stack: error.stack,
      videoUrls: videoUrls?.length
    });
    logEndpoint('/send-video-to-contacts-grouped', 'POST', req.body, { error: error.message });
    return res.status(500).json({ error: "Video iÅŸlem hatasÄ±: " + error.message });
  }
});


app.get("/healthz", (req, res) => res.json({ ok: true, ready }));

// Logout API - SADECE LOGOUT, SESSION SÄ°LME!
app.post("/logout", async (req, res) => {
  const startTime = Date.now();
  logEndpoint('/logout', 'POST', req.body, 'started');

  try {
    console.log("[LOGOUT] WhatsApp oturumu kapatÄ±lÄ±yor... (Session korunacak)");
    logger.info('[LOGOUT] Starting logout', { ready, hasClient: !!client });

    if (client) {
      await client.logout();
      console.log("[LOGOUT] WhatsApp client logout yapÄ±ldÄ±.");
      logger.info('[LOGOUT] Client logged out');
    }

    // Session dosyalarÄ±nÄ± SÄ°LME! Sadece durumu gÃ¼ncelle
    ready = false;
    lastQrString = null;

    const processingTime = Date.now() - startTime;
    const response = {
      success: true,
      message: "WhatsApp oturumu kapatÄ±ldÄ±. Session dosyalarÄ± korundu.",
      processingTime
    };

    logger.info('[LOGOUT] Success', { processingTime });
    logEndpoint('/logout', 'POST', req.body, response);
    res.json(response);

    console.log("[LOGOUT] Session dosyalarÄ± korundu. Yeniden baÄŸlanmak iÃ§in server'Ä± restart edin.");

  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error('[LOGOUT] Error', { error: error.message, stack: error.stack, processingTime });
    logEndpoint('/logout', 'POST', req.body, { error: error.message, details: error.message, success: false, processingTime });

    console.error("[LOGOUT] Hata:", error);
    res.status(500).json({
      error: "Logout sÄ±rasÄ±nda hata oluÅŸtu.",
      details: error.message
    });
  }
});

// YENÄ° API: Session'Ä± temizle (sadece gerÃ§ekten gerektiÄŸinde)
app.post("/clear-session", async (req, res) => {
  const startTime = Date.now();
  logEndpoint('/clear-session', 'POST', req.body, 'started');

  try {
    console.log("[CLEAR-SESSION] Session cache temizleniyor...");
    logger.info('[CLEAR-SESSION] Starting session clear', { ready, hasClient: !!client });

    // Ã–nce WhatsApp'tan Ã§Ä±kÄ±ÅŸ yap
    if (client && ready) {
      await client.logout();
      console.log("[CLEAR-SESSION] WhatsApp client logout yapÄ±ldÄ±.");
      logger.info('[CLEAR-SESSION] Client logged out');
    }

    // Session cache'ini temizle
    const sessionPath = path.join(process.cwd(), 'wweb-session');
    let sessionDeleted = false;
    if (fs.existsSync(sessionPath)) {
      fs.rmSync(sessionPath, { recursive: true, force: true });
      console.log("[CLEAR-SESSION] Session cache temizlendi:", sessionPath);
      logger.info('[CLEAR-SESSION] Session cache deleted', { sessionPath });
      sessionDeleted = true;
    }

    // Durumu gÃ¼ncelle
    ready = false;
    lastQrString = null;

    const processingTime = Date.now() - startTime;
    const response = {
      success: true,
      message: "Session cache tamamen temizlendi. Yeni QR kod gerekli.",
      sessionDeleted,
      processingTime
    };

    logger.info('[CLEAR-SESSION] Success', { sessionDeleted, processingTime });
    logEndpoint('/clear-session', 'POST', req.body, response);
    res.json(response);

    // 2 saniye sonra server'Ä± yeniden baÅŸlat
    setTimeout(() => {
      console.log("[CLEAR-SESSION] Server yeniden baÅŸlatÄ±lÄ±yor...");
      logger.info('[CLEAR-SESSION] Restarting server');
      process.exit(0);
    }, 2000);

  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error('[CLEAR-SESSION] Error', { error: error.message, stack: error.stack, processingTime });
    logEndpoint('/clear-session', 'POST', req.body, { error: error.message, details: error.message, success: false, processingTime });

    console.error("[CLEAR-SESSION] Hata:", error);
    res.status(500).json({
      error: "Session temizleme sÄ±rasÄ±nda hata oluÅŸtu.",
      details: error.message
    });
  }
});

// Global error handler - JSON response dÃ¶ndÃ¼r (HTML yerine)
app.use((err, req, res, next) => {
  logger.error('[EXPRESS ERROR]', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method
  });

  console.error('[EXPRESS ERROR]', err.message);
  console.error('[EXPRESS ERROR] Stack:', err.stack);

  // JSON response dÃ¶ndÃ¼r
  res.status(err.status || 500).json({
    error: err.message || 'Internal Server Error',
    status: err.status || 500
  });
});

app.listen(PORT, '0.0.0.0', () => {
  logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  logger.info(`âœ… WhatsApp Web.js Server Started`);
  logger.info(`   Local URL: http://localhost:${PORT}`);
  logger.info(`   Base Path: ${BASE_PATH || '(direct access)'}`);
  logger.info(`   Log Files: ${logDir || 'Console only'}`);
  logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  // ngrok'u sadece USE_NGROK=true ise baÅŸlat (localhost geliÅŸtirme iÃ§in)
  // Render.com/production ortamlarÄ±nda USE_NGROK kullanma!
  if (process.env.USE_NGROK === 'true') {
    logger.info('[TUNNEL] USE_NGROK=true, ngrok baÅŸlatÄ±lÄ±yor...');
    startTunnel();
  } else {
    logger.info('[TUNNEL] ngrok devre dÄ±ÅŸÄ± (USE_NGROK ayarlanmamÄ±ÅŸ)');
  }
});
